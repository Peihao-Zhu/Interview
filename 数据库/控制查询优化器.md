## 1.控制查询优化评估

查询优化器的任务就是找到一个最佳计划去执行一个SQL查询，因为好和坏的查询性能差异可能是几个数量级。大多数的查询优化器都或多或少的进行详尽的搜索为了在众多可能的查询计划中找到最佳计划。对于联表查询，MySQL优化器搜索的执行计划会与引用到的表数量成指数级增长。对于少量表（少于7-10张），没什么关系，但是当一个更大的查询被提交，花费在查询优化上的时间会成为服务器性能的瓶颈。

我们可以通过控制优化器执行计划的搜索数来平衡花费在这上面的时间，如果优化器调查更少的查询计划，就会花费更少的时间编译一个查询，但是如果跳过某些执行计划，就可能回错过一个最佳计划。

MySQL可以通过两个变量来控制优化器评估的查询计划

- optimizer_prune_level：优化器根据预估访问表的行数来跳过一些特定的查询计划，经验告诉我们这种有经验的猜测很少会错过最优的计划，并且会极大的降低编译时间，所以这个选择是被默认开启的。但是如果你相信优化器没有使用你认为最佳的查询计划，你可以把这个模式关闭，但是这样会让优化器花费大概指数级的时间
- optimizer_search_depth：该指令是告诉优化器查看每个不完整计划的未来可能性，来评估是否应该在未来被扩展。该值较小，可以让查询编译时间缩短几个数量级，如果这个变量设置为0，那么优化器自动确定编译计划。

## 2.优化提示

可以在单个语句中指定，由于优化程序提示是基于每个语句应用的，因此相比于optimizer_switch有更好的控制语句执行计划。优先级高于optimizer_switch。

optimizer hint总览：

- Global：提示影响整个语句
- Query Block：提示影响语句中的特定语句块
- Table-Level：影响查询块中的特定表
- Index-Level：影响查询表中的特定索引

## 3.索引提示

索引提示只能用在SELECT 和UPDATE语句



## 4.优化器成本模型

为了生成执行计划，优化器使用成本模型，该模型基于对查询执行期间的各种操作的成本进行估算。优化器具有一组内置的默认“成本常数”，用于指定有关执行计划的决策。

优化器还有一个成本估算数据库，这些估值存储在MySQL系统数据库的server_cost和engine_cost中，可以随时配置，这些表的目的是可以轻松的调整优化器会使用的成本估计值，当优化器要尝试得出查询执行计划的时候。

**Cost Model General Operation**

- 服务器在启动时将成本模型表读到内存中，并在运行时使用内存中的值。表中非空值的成本估计值又闲鱼已编译的成本常量，空值的话会使用编译后的默认值。
- 在运行时，服务器回重新读取成本表，当动态加载存储引擎或执行FLUSH OPTIMIZER_COSTS语句时，会发生这种情况
- 成本表是服务器管理员可以通过更改表的条目轻松调整成本估算，通过将条目的成本设置为NULL，也很容易恢复为默认值。优化器使用内存中的成本值，所以每次对条目进行修改后，都要执行FLUSH OPTIMIZER_COSTS语句生效。
- 客户会话开始时当前的内存中成本估算将在整个会话中应用，直到结束。如果服务器重新读取成本表，那些更改的估算值，只有在随后启动的会话才有效。
- 成本表对于给定的服务器实例是特定的，服务器不会讲成本表更改复制到副本。

**Cost Model Database**

成本模型数据库包含两张表，server_cost 和engine_cost表。

server_cost表包含一下字段：

- cost_name:是主键，成本估算的名称
- cost_value:是成本估算的值，如果非空，就是使用该值；如果为空，就使用编译值
- last_update:最后一次行更新时间
- default_value:成本估算的默认值，是只读列。

engine_cost表包含以下字段：

- engine_name：
- device_type：成本估算使用的设备类型，为不同的存储设备类型（硬盘驱动器与固态驱动器），指定不同的成本估算

其他字段和server_cost表相同

engine_cost表的主键是由（cost_name,engine_name,device_type）列组成的元组

服务器会识别成本名对于engine_cost表

- Io_block_read_cost：从磁盘读取索引或数据块的成本。与读取较少磁盘块的查询计划相比，增加该值会使读取许多磁盘快的查询计划变得更加昂贵。
- memory_block_read_cost：和前者类似，但表示从内存数据库缓冲区读取索引或数据块的成本。

如果上面两个值不同，那么执行计划可能在同一查询的两次运行之间改变。假定内存访问的成本小于磁盘访问成本，在此情况下，服务器启动之前，将数据读入缓冲池之前，你可能会获得与运行查询之后不同的计划，因为这样数据会存储在内存中。