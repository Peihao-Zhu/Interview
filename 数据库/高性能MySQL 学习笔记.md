## 1.服务器性能剖析

### 1.1剖析MySQL查询

​		先剖析整个数据库服务器，分析出哪些查询时主要的压力来源。定位到具体需要优化的查询后，可以钻取下去对这些查询进行单独的剖析，分析哪些子任务是响应时间的主要消耗者。

- 剖析服务器负载

**慢查询日志**的功能原本知识捕获比较慢的查询，在MySQL5.0之前的版本中，慢查询日志的响应时间单位是s，粒度太粗了。在MySQL5.1以后可以通过设置long_query_time为0来捕获所有查询，而且查询单位是微妙。

在MySQL当前版本中，慢查询日志是开销最低、精度最高的测量查询时间的工具。

**分析查询日志**

不要直接打开整个慢查询日志进行分析，首先生成一个剖析报告，这里建议使用pt-query-digest。一般情况下，只需要将满查询日志文件作为参数传递给pt-query-digest，就可以工作了。它会讲查询报告打印出来，并切能够选择将“重要的查询”逐条打印出更详细的信息![image-20200821104937297](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200821111636.png)

- 剖析单条查询

**使用SHOW PROFILE**

该命令在MySQL 5.1以后引入，默认是禁用的,可以通过以下命令开启

```mysql
mysql>SET profiling=1
```

当执行一条查询语句时，在使用show profiles命令，返回如下：

```mysql
mysql> select * from book;
mysql> show profiles;
+----------+------------+--------------------+
| Query_ID | Duration   | Query              |
+----------+------------+--------------------+
|        1 | 0.00551700 | select * from book |
+----------+------------+--------------------+
1 row in set, 1 warning (0.00 sec)

```

还可以使用下面的查询语句,查看更详细的细节。但是这存在一个问题，输出是按照执行顺序排序，并不是按照花费时间排序。

```mysql
mysql> show profile for query 1;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000486 |
| Executing hook on transaction  | 0.000019 |
| starting                       | 0.000009 |
| checking permissions           | 0.000005 |
| Opening tables                 | 0.000286 |
| init                           | 0.000264 |
| System lock                    | 0.000279 |
| optimizing                     | 0.000019 |
| statistics                     | 0.000019 |
| preparing                      | 0.000019 |
| executing                      | 0.004036 |
| end                            | 0.000014 |
| query end                      | 0.000004 |
| waiting for handler commit     | 0.000008 |
| closing tables                 | 0.000010 |
| freeing items                  | 0.000017 |
| cleaning up                    | 0.000023 |
+--------------------------------+----------+
17 rows in set, 1 warning (0.00 sec)

```

为了解决上面这个可以直接查询 INFORMATION_SCHEMA对应的表![image-20200821111624011](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200821111624.png)

可以发现查询时间太长主要是因为花了一大半时间将数据复制到临时表，“发送数据”也消耗很多时间，可能是不同的服务器活动，包括在关联时搜索匹配的行记录等。

但要分析为什么复制数据到临时表要话费这么多时间需要进一步剖析子任务

**SHOW STATUS**

该命令返回的都是计数器，显示某些活动如读索引的频繁程度，但无法给出消耗多少时间。既有服务器级别的全局计数器，也有基于某个连接的会话级别的计数器。

SHOW STATUS可以猜测哪些操作代价较高或者消耗时间较多。最有用的计数器包括句柄计数器、临时文件和表计数器等。下面例子演示了如何将会话级别的计数器重置为0，然后查询前面提到的视图，在检查计数器的结果：

![image-20200821112905334](/Users/zhupeihao/Library/Application Support/typora-user-images/image-20200821112905334.png)

从结果可以看到，该查询使用了三个临时表，其中两个是磁盘临时表，并且有很多没有用到索引的读操作（Handler_read_rnd_next）

### 1.2诊断间歇性问题

间歇性问题比如系统偶尔停顿或者慢查询，很难诊断。如果一时无法定位问题，可能是测量的方式不正确，或者测量的点选择有误，或者使用的工具不合适。

- 单条查询问题还是服务器问题

单条查询问题：服务器整体运行没有问题，知识某条查询变慢

服务器问题：服务器所有的程序都突然变慢，又突然变好，每一条查询也都变慢了。

如何判断是哪种问题？

1. SHOW GLOBAL STATUS命令，每秒一次执行通过返回的计数器来分析

![image-20200821125233445](/Users/zhupeihao/Library/Application Support/typora-user-images/image-20200821125233445.png)

这个命令每秒捕获一次SHOW GLOBAL STATUS，输出给awk计算并输出每秒的查询数、Threads_connected和Threads_running。这三个数据的趋势对于服务器级别偶尔停顿的敏感性很高

   2.SHOW PROCESSLIST，不停捕获该命令的输出，来观察是否有大量线程处于不正常的状态或有其他不正常的特征。



## 2. Schema与数据类型优化

### 2.1选择优化的数据类型

1. 更小的通常更好：一般情况，尽量使用正确存储数据的最小数据类型。
2. 简单就好：简单数据类型通常需要更少的CPU周期
3. 尽量避免NULL：NULL会使的索引、索引统计和值都更复杂，所以把列改为NOT NULL。

**2.1.1整数类型**

TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT分别使用8，16，24，32，64位存储空间。整数类型又可选的UNSIGNED属性，表示不允许负值，也就是第一位不是符号位。这样的话可以是正数的上限提高一倍。

**2.1.2实数类型**

实数是带有小数部分的数字。MySQL支持精确类型（DECIMAl），也支持不精确类型（FLOAT、DOUBLE）。

浮点类型存储同样范围的值，通常比DECIMAL使用更少的空间。FLOAT占4字节，DOUBLE占8字节相比FLOAT有更高的精度和更大的范围。

因为需要额外的空间和计算开销，应该尽量只在对小数进行精确计算时才使用DECIMAL，但在数据量大的时候，可以考虑使用BIGINT代替DECIMAL，乘小数的位数，

**2.1.3字符串类型**

**VARCHAR**

VARCHAR用于存储可变长字符串，仅使用必要的空间，需要使用1或2个额外字节记录字符串长度：如果长度小于或等于255，只使用1个字节表示，否则使用2个字节。

VARCHAR节省存储空间，对性能有帮助。但是，由于行是变成的，在UPDATE以后可能行变得很长，如果页内没有更多的空间存储，此时不同的存储引擎的处理方式是不一样的。MyISAM会讲行拆成不同的片段存储，InnoDB需要分裂页来使行可以放进页内。

**CHAR**

CHAR是定长的，MYSQL在服务器层灰删除所有末尾的空格。适合存储很短的字符串，因为CAHR（1）只有1个字节，而VARCHAR（1）需要2个字节，因为额外1个字节用来存储长度。

**BLOB和TEXT**

两者都是存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

字符类型有TINYTEXT，SMALLTEXT，TEXT，MEDIUMTEXT，LONGTEXT；对应的二进制类型是TINYBLOB，SMALLBLOB，BLOB，MEDIUMBLOB，LONGBLOB。

MySQL对BLOB和TEXT列进行排序与其他类型不同：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。

**2.1.4日期和时间类型**

MySQL可以使用YEAR、DATE等类型来保存日期和时间值。MySQL能存储的最小时间粒度是s（MariaDB支持微妙级别）。

**DATETIME**

能保存大范围的值，从1001年到9999年，精度为s，使用8字节的存储空间。

**TIMESTAMP**

保存从1970年1月1日到2038奶奶，4个字节存储。比DATETIME空间效率更高

### 2.2MySQL schema设计的陷阱

**太多的列**

MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MyISAM的定长行结构实际上与服务器层的行结构正好匹配，所以不需要转换。然而MyISAM变长行结构和InnoDB的行结构则总是需要转换，转换的代价需要依赖列的数量。

**太多的关联**

单个查询最好在12个表以内做关联

**NULL值设定**

尽可能考虑替代NULL，比如用0、空字符串等，但是也不要走极端，

有时候用NULL可能效果反倒要好。

### 2.3范式和反范式

​		**范式优点**

- 更新操作比反范式化更快

- 数据较好的范式化，只有很少或者没有重复数据，修改数据量也更小

- 范式化的表通常更小，更好的放在内存，执行操作更快。

- 冗余的数据更少，所以更少的需要使用DISTINCT或者GROUP BY字段。

  **范式缺点**

查询的时候经常要关联表

所以在实际开发中可以混用范式化和反范式化。

### 2.4加快ALTER TABLE操作的速度

MySQL执行大部分修改表结构操作的方法使用心得结构创建一个空表，从旧表查处所有数据插入新表，然后删除旧表。一般而言，大部分ALTER TABLE操作会导致MySQL服务中断，我们会使用两个技巧来解决：一种是先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换；另外一种技巧是影子拷贝，用要求的表结构创建一张和原表无关的新表，然后通过重命名和删表操作交换两张表。

但不是所有的 ALTER TABLE操作都会引起表重建，如果知识修改列字段的默认值，会直接修改.frm文件而不设计表数据，所以操作非常快。

**只修改.frm文件**

1. 创建一张有相同结构的空表，并进行所需要的修改
2. 执行FLUSH TABLES WITH READ LOCK。关闭所有正在使用的表，禁止任何表被打开
3. 交换.frm文件
4. 执行UNLOCK TABLES

## 3创建高性能的索引

### 3.1索引基础

#### 3.1.1索引的类型

索引是在存储引擎层而不是服务器层实现的，所以，没有统一的索引标准。

**B-Tree**

在没有特别指明什么索引类型的时候，基本上都是B-Tree索引，InnoDB使用B+Tree，NDB使用T-Tree作为索引。

存储引擎以不同的方式使用B-Tree索引，性能也各不相同。例如：MyISAM使用前缀压缩技术使得索引更小，但InnoDB按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

使用B-Tree索引的查询类型，适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。

建立索引（姓，名，生日）

- 全值匹配
- 匹配最左前缀
- 匹配列前缀：匹配某一列的值的开头部分
- 匹配范围值：查找姓在一个范围之间的人
- 精确匹配某一列并范围匹配另一列
- 只访问索引的查询

如果不是上面几种情况，就无法使用索引，比如说知识查询名为Bill的人，或生日为...的人，类似的这些都不符合最左数据列。如果某个列卫范围查询，那么其右边所有列都无法使用索引优化查找。

### 3.2聚簇索引

聚簇索引是一种数据存储方式，数据存放在索引的叶子节点中。一些数据库服务器允许选择哪个索引作为聚簇索引，但是MySQL内建的存储引擎还没有支持这一点。InnoDB通过主键聚集数据。如果没有定义主键，InnoDB回选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB回隐式定义一个主键来作为聚簇索引。

聚集数据的好处：

- 把相关数据保存在一起。如：实现电子邮箱时，根据用户ID聚集数据，这样要获取用户的全部邮件，只需要从磁盘读取少量数据页就可以，否则需要每封邮件都进行一次磁盘IO
- 数据访问更快。将索引和数据都保存在同一个B-Tree中，因此聚簇索引中获取数据通常比非聚簇索引快
- 使用覆盖索引扫描的查询可以直接使用页节点的主键值

聚簇索引的缺点

- 插入速度严重依赖于插入顺序。按照主键顺序插入时加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么加载完成后最好使用OPTIMIZE TABLE命令重新组织表。
- 更新聚簇索引列的代价很高，导致每个被更新的行都移动位置
- 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行是，可能面临页分裂，页分裂会导致表占用更多磁盘空间。
- 聚簇索引可能导致全表扫描更慢
- 耳机索引可能比想象要更大

**InnoDB和MyISAM的数据分布区别**

MyISAM按照数据插入顺序存储在磁盘上，新插入的一行数据就存储在下一个磁盘空间。建立索引，是针对索引进行排序（这是B+Tree的特性）。关于索引，MyISAM没有分聚簇和二级索引，所有索引的分布方式都一样。

InnoDB的索引存储方式不同

![image-20200823154723903](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200823154724.png)

虽然也是按照主键顺序进行排序，但是叶子节点存储了整个表的数据，包含了主键值、事务ID、用于事务和MVCC的回滚指针以及其他列。如果主键是一个列前缀索引，InnoDB也会抱憾完整的主键列和剩余列。

**在InnoDB表中按主键顺序插入行**

如果使用InnoDB表，没有什么数据需要聚集，可以使用自增列，作为主键，这样可以保证数据行是按顺序写入。

最好避免随机聚簇索引，例如：用UUID作为聚簇索引会很糟糕，是的索引的插入变得完全随机。

为了演示，测试两张表，只有主键有区别（一个是自增ID，一个是UUID），分别网两个表插入100万条记录。然后向这两个表继续插入300万条记录。

![image-20200823155724418](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200823162018.png)

可以发现使用了uuid的表不仅插入时间更长，而且建立的索引也很大，原因在于页分裂和碎片。

向聚簇索引中插入顺序的索引值时，InnoDB把每一条记录存储到上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。

![image-20200823162008163](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200823162008.png)

那么如果插入的是无序的值？

![image-20200823212204779](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200823212204.png)

因为新行的主键值不一定比前一条记录大，所以会产生以下缺点：

- 写入的目标页可能已经刷到磁盘上并从缓存中移除，InnoDB在插入之前需要先找到磁盘中的目标页读到内存中。这将导致大量的随机IO
- 因为写入的乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间
- 由于频繁的页分裂，页会变得稀疏，最终数据会有碎片



### 3.3覆盖索引

索引不仅是查找数据的高效方式，还可以直接用来获取列的数据。如果索引包含需要查询的字段值，就称为“覆盖索引”。

- 索引条目通常远小于数据行大小，所以只读取索引，MySQL可以极大键撒后数据访问量。这对缓存的负载非常重要，因为这种情况下，响应时间大部分花在拷贝上。覆盖索引对与IO密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存。
- 因为索引是按照列值顺序存储（至少单个页内如此），对于IO密集型的范围查询会比随机从磁盘中读取每一行数据的IO要少得多。
- 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此访问数据需要一次系统调用。这对于频繁访问数据的系统会导致严重的性能问题。
- 在InnoDB中，二级索引在叶子节点只保存了行的主键值，所以如果二级主键能覆盖查询，就可以避免对主键索引的二次查询。

不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引都不存储索引列的值，所以只能用B-Tree索引做覆盖索引。

在EXPLAIN的Extra列可以看到，如果表inventory又一个多列索引（store_id,film_id）

![image-20200823222547201](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200823222547.png)

MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了where条件中的字段，但不是整个查询涉及的字段，就会去了回表，尽管where条件为false。

![image-20200823232148589](https://cdn.jsdelivr.net/gh/Peihao-Zhu/blogImage@master/data/20200823232148.png)

无法覆盖的原因：

P209页