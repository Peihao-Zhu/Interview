[TOC]







## 1 ★★☆ 连接查询与子查询的比较。

https://www.cnblogs.com/xiaoxi/p/6734025.html

**笛卡尔积（全相乘）**

​		全相乘效率低，全相乘会在内存中生成一个非常大的数据(临时表)，因为有很多不必要的数据。

　	如果一张表有10000条数据，另一张表有10000条数据，两表全相乘就是100W条数据，是非常消耗内存的。而且，全相乘不能好好的利用索引，因为全相乘生成一张临时表，临时表里是没有索引的，大大降低了查询效率。

**左连接**

使用左连接查询达到了同样的效果，但是不会有其它冗余数据，查询速度快，消耗内存小，而且使用了索引。左连接查询效率相比于全相乘的查询效率快了10+倍以上。

**全连接**

全连接会将两个表的所有数据查询出来，不满足条件的为NULL。

全连接查询跟全相乘查询的区别在于，如果某个项不匹配，全相乘不会查出来，全连接会查出来，而连接的另一边则为NULL。



**子查询**

子查询虽然很灵活，但是执行效率并不高
执行子查询时，MYSQL需要创建临时表，查询完毕后再删除这些临时表，所以，子查询的速度会受到一定的影响，这里多了一个创建和销毁临时表的过程

## 2 ★★☆ drop、delete、truncate 比较。

- 作用

  delete：可以删除表中的指定数据

  truncate：清空整个表（把表中的数据都删除）

  drop：把表结构也删除了（删的最彻底）

- 事务

  delete会被放到日志，以便进行回滚

  truncate和drop是立即生效，命令不会存到日志中。

- 删除空间

  delete不会减少表和索引占用的空间

  truncate会将表和索引占用的空间恢复到初始值

  drop会将表和索引所占有的空间释放

- 耗时

  Drop>truncate>delete

## 3 ★★☆ 视图的作用，以及何时能更新视图。

一条查询语句执行后返回的结果集，是一个虚拟表，包含带有名称的行列。但视图中不包含真实的数据，真实数据都在原始表中。

​		**作用**

- 简化复杂的查询，比如复杂的连接查询，在编写查询后，可以方便的重用它还不必知道基本细节。

  ```mysql
  create view productcustomers as
  select cust_name, cust_contact, prod_id
  from customers, orders, orderitems
  where customers.cust_id = orders.cust_id 
  and orderitems.order_num = orders.order_num;
  ```

  该语句创建一个名为productcustomers的视图，连接了三个表来返回购买商品的客户信息。

  ```mysql
  SELECT * FROM productcustomers;
  ```

  通过上面的语句可以重复使用结果，而不需要了解基本的细节。

- 只使用实际表的一部分数据；

- 通过只给用户访问视图的权限，保证数据的安全性；

- 更改数据格式。视图可以返回与底层表格式不同的数据

  假如需要返回的数据格式用到了concat或者其他字符串拼接，不需要每次查询都执行连接，可以创建一个视图，需要的时候直接使用这个视图。如

  ```mysql
  create view vendorlocations as 
  select concat(RTrim(vend_name), '(', RTrim(vend_country), ')') as vend_title 
  from vendors 
  order by vend_name;
  
  ```

  

  

  **何时更新**

  因为视图不存储数据，所以更新视图需要去更新原始表。如果视图定义只依赖于一个原始表，就很容易进行更新操作。但如果视图定义中有以下操作，那么就不能进行视图的更新：

  - 分组查询
  - 连接查询
  - 子查询
  - Union
  - 聚集函数
  - DISTINCT
  - 计算字段

## 4 ★☆☆ 理解存储过程、触发器等作用。

**存储过程**

对一系列SQL操作的批处理。

- 代码封装，保证一定的安全性

- 代码复用

- 预先编译，具有很高的性能

 

**触发器**

触发器在执行以下语句时自动执行：DELETE、INSERT、UPDATE

触发器必须指定在语句执行之前还是之后自动执行，之前执行用BEFORE关键字，之后执行用AFTER关键字。BEFORE用于数据验证和净化，AFTER用于审计跟踪，将修改记录到另外一张表中

## 5 ★★★ B+ Tree 原理，与其它查找树的比较。

B tree 是平衡树，所有叶子节点都在同一层，非叶子节点也可以存储数据，B+ Tree是基于B Tree和叶子结点顺序访问指针实现的，所有数据都存放在叶子结点。可以通过顺序访问提高区间之间查询的性能。 

**m 阶 B 树的性质（m ≥ 2）**

m 阶 B 树指的是一个结点最多拥有 m 个子结点。假设一个结点存储的元素个数为 x，那么如果这个结点是：

- 根结点：1 ≤ x ≤ m - 1
- 非根结点：┌ m / 2 ┐ - 1 ≤ x ≤ m - 1

如果有子结点，子结点个数为 y = x + 1，那么如果这个结点是：

- 根结点：2 ≤ y ≤ m

- 非根结点：┌ m / 2 ┐ ≤ y ≤ m

  

查找时，首先在根节点进行二分查找，然后递归的在key指向的节点进行查找。

与红黑树比较；

（一）B+树高度更低

B+树可以有n个孩子，而红黑树最多只有2个孩子，所以B+树高度更低。

（二）磁盘访问原理

操作系统将内存和磁盘分割成固定大小的块，一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，一次IO就会完全载入一个节点。 

如果数据不在同一个磁盘块上，需要移动制动手臂进行寻道，而制动手臂因为物理结构增加磁盘数据读取时间。B+树相对于红黑树更低，进行寻道次数更少。

（三）磁盘预读特性

为了减少磁盘IO，磁盘往往不是严格按需读取，每次会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，相邻的节点会被预先载入。

## 6 为什么MySQL要使用B+Tree

https://blog.csdn.net/qq_39751320/article/details/108716793

InnoDB的主键索引还是辅助索引，都是使用B+Tree来存储数据的，主键索引中通过主键id查找所有信息，辅助索引中通过索引值index查找对应的主键id。



#### B+Tree和B Tree、Hash几个结构的比较

在挑选存储数据的结构时基于以下两点来考虑：

- InnoDB 需要支持的场景和功能需要在特定查询上拥有较强的性能；
- CPU 将磁盘上的数据加载到内存中需要花费大量的时间，这使得 B+ 树成为了非常好的选择；

数据持久化和数据查询是很常见的需求，而持久化就要与磁盘、内存和CPU打交道。

**读写性能**

使用B Tree或B+Tree查询数据的复杂度都是在O(logn)，但是Hash查询单条数据可以达到O(1)的复杂度。

不过Hash一旦遇到分组查询，范围查询，排序等操作，只能进行全表扫描.相反B+ Tree 因为结构的特性，本身键是按照顺序存储的，相邻的数据都是自然排序，在以上操作中性能更好

**数据加载**

对于B和B+Tree的区别其实也很简单----计算机在读写文件时会以页为单位将数据加载到内存中。页的大小可能会根据操作系统的不同而发生变化，不过在大多数的操作系统中，页的大小都是 `4KB`，你可以通过如下的命令获取操作系统上的页大小:

```
$ getconf PAGE_SIZE
4096
```

当我们需要在数据库中查询数据时，CPU 会发现当前数据位于磁盘而不是内存中，这时就会触发 I/O 操作将数据加载到内存中进行访问，数据的加载都是以页的维度进行加载的，然而将数据从磁盘读取到内存中所需要的成本是非常大的，普通磁盘（非 SSD）加载数据需要经过队列、寻道、旋转以及传输的这些过程，大概要花费 `10ms` 左右的时间。

我们在估算 MySQL 的查询时就可以使用 `10ms` 这个数量级对随机 I/O 占用的时间进行估算，这里想要说的是随机 I/O 对于 MySQL 的查询性能影响会非常大，而顺序读取磁盘中的数据时速度可以达到 40MB/s，这两者的性能差距有几个数量级，由此我们也应该尽量减少随机 I/O 的次数，这样才能提高性能。

**B 树与 B+ 树的最大区别就是**，B 树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中，当一个表底层的数据结构是 B 树时，假设我们需要访问所有『大于 4，并且小于 9 的数据』：

![WeChat75437d38134a26d572046377ebf9ebaf](/Users/zhupeihao/Library/Containers/com.tencent.xinWeChat/Data/Library/Caches/com.tencent.xinWeChat/2.0b4.0.9/1ab32f76abfa38116a670b7ac59c1027/dragImgTmp/WeChat75437d38134a26d572046377ebf9ebaf.png)

如果不考虑任何优化，在上面的简单 B 树中我们需要进行 4 次磁盘的随机 I/O 才能找到所有满足条件的数据行：

1. 加载根节点所在的页，发现根节点的第一个元素是 6，大于 4；
2. 通过根节点的指针加载左子节点所在的页，遍历页面中的数据，找到 5；
3. 重新加载根节点所在的页，发现根节点不包含第二个元素；
4. 通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到 7 和 8；

当然我们可以通过各种方式来对上述的过程进行优化，不过 B 树能做的优化 B+ 树基本都可以，所以我们不需要考虑优化 B 树而带来的收益，直接来看看什么样的优化 B+ 树可以做，而 B 树不行。

由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，也是 B 树最大的性能问题。

B+ 树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以**通过『指针』依次按顺序连接**，当我们在如下所示的 B+ 树遍历数据时可以直接在多个子节点之间进行跳转，这样能够节省大量的磁盘 I/O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能

![image-20200719122108571](/Users/zhupeihao/Library/Application Support/typora-user-images/image-20200719122108571.png)

## 7 ★★★ MySQL 索引以及优化。	

https://blog.csdn.net/qq_39751320/article/details/106280118

 

索引是在存储引擎层实现的，不是在服务器层，所以不同的存储引擎有不同的索引类型和实现。

**索引类型**

1. B+Tree 索引

大多数MySQL存储引擎默认使用B+Tree索引，因为不需要全表扫描，只需要对树进行扫描，查询速度快很多。

B+Tree的有序性，除了用于查找，也可以用于排序和分组

可以指定多个列作为索引列，多个索引列共同组成键

InnoDB的 B+Tree索引分为主索引和辅助索引。主索引的叶子结点记录了完整的数据，称为聚簇索引。辅助索引的叶子结点存放着主键的值，所以使用辅助索引查找时，先查到主键值，然后再去聚簇索引中查找具体的数据。

 

2. 哈希索引 

哈希索引能以O（1）时间查找，但是失去了有序性无法用于排序和分组，只支持精确查找，不能用于部分查找和范围查找。

InnoDB有“自适应哈希索引”，当某个索引值被使用的很频繁时，会在B+Tree索引上在创建一个哈希索引。

 

3. 全文索引

MyISAM存储引擎支持全文索引，用于查找文本的关键字，查找条件是MATHCH AGAINST而不是WHERE 

InnoDB在MySQL5.6.4以后也开始支持全文索引

 

4. 空间数据索引

MyISAM存储引擎支持空间数据索引，用于地理数据存储。需要使用GIS相关函数进行维护和部署

 

**索引优化**

1) 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引

2) 多列索引

使用多个列作为条件进行查询时，使用多列索引比单列索引性能更好。

3) 索引列的顺序

索引的选择性：不重复的索引值和记录的总数比（如果索引值都是不重复的，如主键索引，那么比为1）。选择性越高，每个记录的区分度越高，查询效率也越高。

在组合索引中，将选择性高的索引放在前面。

4) 前缀索引

对于BLOB，TEXT和VARCHAR类型的列，必须使用前缀索引，只索引开始部分字符，前缀的长度根据索引选择性来判断。

5) 覆盖索引

索引包含需要查询的字段的值。

优点：

1.索引通常远小于数据行大小，只读取索引能大大减少数据访问量

2.一些存储引擎（如MyISAM）在内存中只缓存索引，而数据依赖于操作系统缓存。因此，只访问InnoDB引擎，如果辅助索引能够覆盖查询，就不需要访问主索引（不需要回表查询）。

 

索引的优点：

- 大大减少服务器需要扫描的数据行数
- 帮助服务器避免排序和分组以及避免创建临时表（B+Tree是有序的，可以用于ORDER BY和GROUP BY操作）
- 将随机IO变成顺序IO（B+Tree索引是有序的，将相邻的数据存储在一起）

## 8 ★★★ 查询优化。

用Explain分析 select语句，分析比较重要的字段：

- select_type:查询类型，简单查询、联合查询、子查询
- key使用索引
- rows扫描的行数

 

优化数据访问

1. 减少请求的数据量

- 只返回必要的列：最好不要用select *
- 只返回必要的行：使用LIMIT语句来限制返回的数据
- 缓存重复查询的数据

 

2. 减少服务端扫描的行数

使用索引覆盖查询

 

重构查询方式

1) 切分大查询

2) 分解大连接查询

 

## 9 ★★★ InnoDB 与 MyISAM 比较。

**InnoDB**

是默认的**事务型存储引擎**，实现了四个标准的隔离级别，默认是可重复读。在可重复读隔离级别下，通过MVCC+Next-Key Lock防止幻读。

主索引是聚簇索引，在索引中保存数据，从而避免直接读取磁盘，因此对查询性能有很大提升。 

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建自适应哈希索引、能够加速插入操作的插入缓冲区。

支持真正的热备份。其他存储引擎不支持在线热备份，要获取一致性视图需要停止对表的写入，而在读写混合场景，停止写入也会停止读取。 



**MyISAM**

不支持事务

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时会对表加排他锁。在表有读取操作的同时，也可以往表中插入新的记录，被称为并发插入。



**比较**

- 事务；InooDB是事务型，可以使用Commit和Rollback语句
- 并发：MyISAM只支持表级锁，而InnoDB还支持行级锁
- 外键：InnoDB支持外键
- 备份：InnoDB支持在线热备份
- 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复速度也慢
- 其他特性：MyISAM支持压缩表和空间数据索引

**具体实现差异的比较**

1. InnoDB不支持FULLTEXT索引
2. InnoDB不保存具体的行数，selete count() from table InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的独处保存好的行数即可。（如果count语句包含where条件时两者操作一样）
3. 对于AUTO_INCREMENT类型的字段，InnoDB必须包含只有该字段的索引，但是在MyISAM可以和其他字段建立联合索引
4. DELETE FROM TABLE，InnoDB不会重新建立表，而是一行一行删除
5. InnoDB的行锁不是绝对的，如果执行一个SQL语句不能确定要扫描的范围，也是会锁住全表



## 10  ★★☆ 水平切分与垂直切分。	

水平切分：将同一个表中的记录拆分到多个结构相同的表中

垂直切分：将一张表按列切分成多张表，按照列的关系密集程度进行切分，也可以利用垂直切分将经常使用的列和不经常使用的列切分到不同表中

## 11  ★★☆ 主从复制原理、作用、实现。

 	https://blog.csdn.net/weixin_43879074/article/details/88525006

原理：

1.一个bin-log记录所有sql语句

2.把主数据库的bin-log文件的sql语句赋值过来

3.让其在从数据库的relay-log重做日志文件中执行一次这些sql语句

 

作用：

- 实现服务器负载均衡。这里有两种思路

  1）主从服务器负责各自的读和写，主服务器只负责数据的更新，查询任务可以由多台从服务器来完成。提高了数据的安全性，也缩短了应用程序的响应时间、提高系统的性能。

  2）在主服务器上与从服务器切分查询作业，也就是说主服务器不仅要完成数据的更新操作，也需要分担部分的查询作业。而从服务器依旧只负责查询

- 通过主从复制实现异地备份

  ​		在传统的备份体制中，是将数据备份在本地，此时备份作业与数据库服务器运行在同一台设备上，当备份作业运行时会阻塞服务器本身的正常运行，降低其性能。同时将备份数据放在本地也不是很安全，如硬盘损坏或服务器被破坏等。

  ​		主从复制可以在备份的过程中不影响主服务器的正常作业（异步复制）。

- 提高数据库系统的可用性

  ​		主从复制实现了主服务器与从服务器之间的数据同步，如果主服务器出现问题，可以让从服务器作为主服务器实现数据的更新功能，然后检查主服务器的故障。此时还可以进行两种操作

  ​	1）主服务器故障后，虽然从服务器代替了主服务器的位置，但是仍然只能进行数据的查询，这主要是基于安全性考虑。如一些银行系统的升级。

  ​	2）从服务器完全代替主服务器，可以进行数据的更新操作。

 

 

实现：

1.binlog线程：每当有从库连接到主库时，binlog线程将主服务器上的日志更改写入二进制日志（Binary log）

2.IO线程：从库的IO线程连接到主库，从主服务器上读取二进制日志，写入从服务器的中继日志（Relay log）

3.从库的SQL线程：从库创建一个SQL线程，这个线程读取从库IO线程写到relay log的更新数据并重新执行（replay）。

 ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png)



**读写分离**

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因就是上面主从复制的作用

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png)

#### 主从复制可能存在的问题，即解决方法

https://blog.csdn.net/darkangel1228/article/details/80003967

**问题：**

- 主服务器宕机后，数据可能丢失
- 从服务器只有一个sql线程，主库写压力大，复制很可能延时。

**解决方法：**

1. 半同步复制---解决数据可能丢失的问题

   ![这里写图片描述](https://img-blog.csdn.net/20180419134031910?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhcmtBbmdlbDEyMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   原理：

   - 事务在主库写完binlog后发送到从库，需要从库发送ack，主库在返回给客户端；

   - 确保事务提交后至少传到一个从库

   - 并不能保证从库能完成响应操作（接受binlog，写relylog），如果从库宕机或者网络异常的话，主库会一直阻塞，直到超时或者从库恢复

     

2. 并行复制---解决从库复制延迟的问题

   从库设置多个sql线程

   ```mysql
   set global slave_parallel_workers=10;
   ```

   



## 12 ★☆☆ redo、undo、binlog 日志的作用。	

- 参考文章 https://blog.csdn.net/qq_39751320/article/details/108903523

## 13 ★★☆  union和union all的区别

https://blog.csdn.net/wanghai__/article/details/4712555

这两个字段都是对查询结果取 **并集**，但是区别是：

- Union不包括重复的行，而union all会包括重复行
- union还会按照默认的规则进行排序，union all不会

具体的例子可以参考前面给出的博客：



**注意：**这里的默认规则是指如果使用select * 则对ID进行排序，如果是select score,name ...则会对score进行排序。当然也可以通过order by来自定义，但是order by字段必须加在最后一个查询语句的后面。

## 14 ★★★ InnoDB如何存储数据

https://www.jb51.net/article/134901.htm

从物理意义上来讲，InnoDB表由共享表空间文件（ibdata1）、独占表空间文件（ibd）、表结构文件（.frm）、以及日志文件（redo文件等）组成。

1. 表结构文件

   在MySQL中建立任何一张表，都会生成.frm文件，用来保存每个数据表的元数据。和存储引擎无关，用来在数据库崩溃时恢复表结构。

2. 表空间文件

   （1）表空间结构分析

![img](https://img.jbzj.com/file_images/article/201802/20182101417001.jpg)

数据段即B+树的叶子节点，索引段即为B+树的非叶子节点，InnoDB存储引擎的管理是由引擎本身完成的，表空间（Tablespace）是由分散的段(Segment)组成。一个段(Segment)包含多个区（Extent）。

区（Extent）由64个连续的页（Page）组成，每个页大小为16K，即每个区大小为1MB，创建新表时，先使用32页大小的碎片页存放数据，使用完后才是区的申请（InnoDB最多每次申请4个区，保证数据的顺序性能）
页类型有：数据页、Undo页、系统页、事务数据页、插入缓冲位图页、以及插入缓冲空闲列表页。

​		（2）独占表空间文件

若将innodb_file_per_table设置为on，则系统将为每一个表单独的生成一个table_name.ibd的文件，在此文件中，存储与该表相关的数据、索引、表的内部数据字典信息。

​		（3）共享表空间文件

在InnoDB存储引擎中，默认表空间文件是ibdata1（主要存储的是共享表空间数据），初始化为10M，且可以扩展，使用共享表空间存储方式时，Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。

而在使用单独表空间存储方式时，每个表的数据以一个单独的文件来存放，这个时候的单表限制，又变成文件系统的大小限制了。

​		（4）共享表空间和独占表空间

共享表空间：一个数据库的所有表数据，索引文件都在一个文件中，默认文件路径在data目录下，默认文件名为ibdata1 初始化为10M

独占表空间：每个表都会生成独立文件方式来进行存储（.ibd文件包括了表数据和索引内容）

- 存储内容：使用了独占表空间以后，每个表的数据、索引和插入缓冲放在独占表空间；每个表的撤销信息、系统事务、二次写缓冲还是存放在共享表空间

- 特点比较

  **共享表空间**

  优点：数据文件方便管理；表空间可以分成多个文件放在各个磁盘中

  缺点：数据和索引放在一个表中，，对一个表做大量删除操作后表空间会有大量的空隙

  **独占表空间**

  优点：不管怎么删除，表空间的碎片不会严重影响性能。

  缺点：单表体积可能过大，超过100G

## 15★★☆MySQL的自增ID用完了怎么办

将id设为int unsigned 最大为2^32-1=4294967295，那么如果初始设置id的auto_increment为这个值，之后在执行插入操作会怎么办呢？

```mysql
17:28:03    insert into t1 values(null) Error Code: 1062. Duplicate entry '4294967295' for key 'PRIMARY'    0.00054 sec
```

会报异常，在插入的时候，自增ID还是4294967295，报主键冲突错误。这个数字已经很大，能应付大部分场景，如果经常要执行插入和删除数据的操作，可以采用bigint unsigned。

**如果创建表的时候没有申明主键，会怎么办？**

InnoDB会自动创建一个6字节的隐式主键row_id，所有未定义主键的表都共享这个row_id。该全局row_id使用了bigint unsigned类型，但是只给了6字节，如果row_id涨到了2^48-1之后在插入数据也会存在主键冲突的风险。

所以为了避免这种隐患，每个表都定义一个主键

# 16★★★select 和 update分别是怎么执行的？

https://mp.weixin.qq.com/s/o-GYPbZIkXTKkMYtuO6m5g

## select语句

当执行一条查询的SQl的时候大概发生了以下的步骤：

1. 客户端发送查询语句给服务器。
2. 服务器首先进行用户名和密码的验证以及权限的校验。
3. 然后会检查缓存中是否存在该查询，若存在，返回缓存中存在的结果。若是不存在就进行下一步。
4. 接着进行语法和词法的分析，对SQl的解析、语法检测和预处理，再由优化器生成对应的执行计划。
5. Mysql的执行器根据优化器生成的执行计划执行，调用存储引擎的接口进行查询。
6. 服务器将查询的结果返回客户端。



### 执行的流程

Mysql中语句的执行都是都是分层执行，每一层执行的任务都不同，直到最后拿到结果返回，主要分为Service层和引擎层，**在Service层中包含：连接器、分析器、优化器、执行器。引擎层以插件的形式可以兼容各种不同的存储引擎。**

Mysql的执行的流程图如下图所示：![图片](https://raw.githubusercontent.com/Peihao-Zhu/blogImage/master/data/640)这里以一个实例进行说明Mysql的的执行过程，新建一个User表，如下：

```
// 新建一个表
DROP TABLE IF EXISTS User;
CREATE TABLE `User` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(10) DEFAULT NULL,
  `age` int DEFAULT 0,
  `address` varchar(255) DEFAULT NULL,
  `phone` varchar(255) DEFAULT NULL,
  `dept` int,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=40 DEFAULT CHARSET=utf8;

// 并初始化数据，如下
INSERT INTO User(name,age,address,phone,dept)VALUES('张三',24,'北京','13265543552',2);
INSERT INTO User(name,age,address,phone,dept)VALUES('张三三',20,'北京','13265543557',2);
INSERT INTO User(name,age,address,phone,dept)VALUES('李四',23,'上海','13265543553',2);
INSERT INTO User(name,age,address,phone,dept)VALUES('李四四',21,'上海','13265543556',2);
INSERT INTO User(name,age,address,phone,dept)VALUES('王五',27,'广州','13265543558',3);
INSERT INTO User(name,age,address,phone,dept)VALUES('王五五',26,'广州','13265543559',3);
INSERT INTO User(name,age,address,phone,dept)VALUES('赵六',25,'深圳','13265543550',3);
INSERT INTO User(name,age,address,phone,dept)VALUES('赵六六',28,'广州','13265543561',3);
INSERT INTO User(name,age,address,phone,dept)VALUES('七七',29,'广州','13265543562',4);
INSERT INTO User(name,age,address,phone,dept)VALUES('八八',23,'广州','13265543563',4);
INSERT INTO User(name,age,address,phone,dept)VALUES('九九',24,'广州','13265543564',4);
```

现在针对这个表发出一条SQl查询：`查询每个部门中25岁以下的员工个数大于3的员工个数和部门编号，并按照人工个数降序排序和部门编号升序排序的前两个部门。`

```
SELECT dept,COUNT(phone) AS num FROM User WHERE age< 25 GROUP BY dept HAVING num >= 3 ORDER BY num DESC,dept ASC LIMIT 0,2;
```

### 连接器

开始执行这条sql时，首先会**校验你的用户名和密码是否正确**，若是不正确会返回错误信息：`"Access denied for user"`；

若是用户名和密码校验通过，**然后就会到权限表获取当前用户拥有的权限**，会检查该语句是否有权限，若是没有权限就直接返回错误信息，有权限会进行下一步，校验权限的这一步是在图一的连接器进行的，对连接用户权限的校验。

**注意：后续的一些列操作都是依赖于这个权限的范围内的。**

### 检索缓存

当建立连接，履行查询语句的时候，会先行检查在缓存区域看看这个sql与否履行过，若是之前执行过，它的执行结果会以`Key-Value`的形式缓存于内存中，Key是`执行的sql`，Value是`结果集`。

假如，缓存中key遭击中，便会直接将结果返回给客户端，假如没命中，便会履行后续的操作，完工之后亦会将结果缓存起来以便再次查询获取，当下一次进行查询的时候也是如此的循环操作。

**注意**：**Mysql中的缓存比较适合于那些静态的表，更新不频繁的表，因为只要当前表有数据更新，有关于该表的缓存就会失效，若是表更新频繁缓存频繁的失效，这样维护缓存的消耗的性能远大于使用缓存带来的性能优化，这样就会得不偿失，严重影响Mysql的性能，所以在Mysql 8版本中的时候把缓存这一块给砍掉了。**

在个人的观点中对于缓存这一块的看法是，没必要砍掉，可以设置成默认关闭缓存，需要的时候再设置开启，并且可以通过配置参数指定特定的表使用缓存，那些表不使用缓存，这样或许使用缓存更有效。

### 分析器

分析器主要有两步：（1）`词法分析`（2）`语法分析`

词法分析主要执行`提炼关键性字`，比如select，`提交检索的表`，`提交字段名`，`提交检索条件`，确定该语句是select还是update或者是delete语句。

语法分析主要执行辨别你`输出的sql与否准确`，是否`合乎mysql的语法`，若是不符合sql语法就会抛出：`You have an error in your SQL syntax`。

### 优化器

查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中`最好的执行计划`。

例如：**在查询语句中有多个索引的时候，优化器决定使用哪一个索引，或者有多表关联的时候，决定表的连接顺序等这些操作都是在优化器决定的**。

生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存。

当`相似的语句`再次被输入服务器时，就可以直接`使用已缓存的执行计划`，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。

![图片](https://raw.githubusercontent.com/Peihao-Zhu/blogImage/master/data/640.png)MySQL使用基于成本的查询优化器。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。

### 执行器

优化器生成得执行计划，交由执行器进行执行，执行器调用存储引擎得读接口，执行器中循环的调用存储引擎的读接口，以此换取满足条件的数据行，并把它放在一个结果集中，遍历并获取了所有满足条件的数据行，最后将结果集返回，结束整个查询得过程。

## update语句

上面我们说完了select语句，select语句的执行过程会经过连接器、分析器、优化器、执行器、存储引擎，同样的update语句也会同样走一遍select语句的执行过程。

![图片](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKlgt6sanGz3AibMgCBzNl4lWm7xYkN46Ux6lawq5FGkJXUGsQMZCcUia6e3rRFQKT1skpSbQ3V9bPO2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)但是和select最大不同的是，update语句会涉及到两个日志的操作`redo log`**（重做日志）** 和`binlog` **（归档日志）**。对于这两个日志的详细介绍，我之前写过一篇文章进行介绍，有兴趣的可以看一看[]：

那么Mysql中又是怎么使用`redo log`和`binlog`？为什么要使用`redo log`和`binlog`呢？直接执行更新然后存库不就行了吗？还要放在`redo log`和`binlog`中，这不是多此一举吗？且听我慢慢道来，这里面大有文章。

### redo log

大家都是知道Mysql是关系型数据库，用来存储数据的，在访问数据库量大的时候，Mysql读写磁盘访问的效率是非常低的，加上sql中的条件对数据的筛选过滤，那么效率就更低了。

这也是为什么引入非关系型数据库作为作为数据缓存原因，例如：`Redis`、`MongoDB`等，就是为了**减少sql执行期间的数据库io操作**。

同样的道理，**若是每次执行update语句都要进行磁盘的io操作、以及数据的过滤筛选，小量的访问和数据量数据库还可以撑住，那么访问量一大以及数据量一大，这样数据库肯定顶不住**。

基于上面的问题于是出现了`redo log`日志，redo log日志也叫做WAL技术（`Write- Ahead Logging`），他是**一种先写日志，并更新内存，最后再更新磁盘的技术**，并且更新磁盘往往是在Mysql比较闲的时候，这样就大大减轻了Mysql的压力。

redo log的特点就是：**redo log是固定大小，是物理日志，属于InnoDB引擎的，并且写redo log是环状写日志的形式**：

![图片](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKlgt6sanGz3AibMgCBzNl4lWm4rUt3PQc0jUOCDB46x0CcCfPNRlrtubqUFKib5aqcbc9ibYk23icvZMIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

如上图所示：若是四组的`redo log`文件，一组为1G的大小，那么四组就是4G的大小，其中`write pos`是**记录当前的位置，有数据写入当前位置，那么write pos就会边写入边往后移**。

而`check point`是**擦除的位置**，因为redo log是固定大小，所以**当redo log满的时候，也就是write pos追上check point的时候，需要清除redo log的部分数据，清除的数据会被持久化到磁盘中，然后将check point向前移动**。

redo log日志实现了即使在数据库出现异常宕机的时候，重启后之前的记录也不会丢失，这就是crash-safe能力。

### binlog

binlog称为归档日志，是逻辑上的日志，它属于Mysql的Server层面的日志，记录着sql的原始逻辑，主要有两种模式，**一个是statement格式记录的是原始的sql，而row格式则是记录行内容**。

那么这样看来redo log和binlog虽然记录的形式、内容不同，但是这两者日志都能通过自己记录的内容恢复数据，那么为什么还要这两个日志同时存在呢？只要其中一个不就行了嘛，两个同时存在不就多此一举了嘛。且听我慢慢道来，这里面也大有文章。

因为刚开Mysql自带的引擎MyISAM就没有crash-safe功能的，并且在此之前Mysql还没有InnoDB引擎，Mysql自带的binlog日志只是用来归档日志的，所以**InnoDB引擎也就通过自己redo log日志来实现crash-safe功能**。

### update执行过程

上面说了那么久两种日志的作用和特点，那么这两种日志究竟和update执行语句有什么关系呢？

先来看图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKlgt6sanGz3AibMgCBzNl4lWmc9jjwwyyK3RYUNry5nSzvEicmUicAyETiaZTwpzy72cvsKZXq6M2zkrcg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

前提：当前的引擎是使用InnoDB，update语句与select语句区别主要是这两日志的使用主要是在执行器和引擎之间进行交互时体现的区别。假如执行如下一条简单的更新语句是：

```
update user set age=age+1 where id =2；
```

上面说过select语句走过的流程update语句也会走一遍，当来到执行器的时候：

1. 执行器会调用引擎的读接口，然后找到id=2的数据行，因为id是主键索引，索引按照树的搜索找到这一行，**若是数据行已经存在于内存的数据页中就会立即将结果返回，若是不在内存中，就会从磁盘中进行加载到内存中，然后将查询的结果返回**。
2. 然后，执行器将返回的结果的age字段+1，并调用引擎的写接口写入更新后的数据行。
3. 引擎获取到更新后的数据行更新到内存和`redo log`中，并告诉执行器可以随时提交事务，此时的`redo log`处于`prepare`阶段。
4. 执行器收到引擎的告知后，生成`binlog`日志，并且调用引擎的接口提交事务，引擎将`redo log`的状态修改为`commit`状态，这样这个更新操作算是完成。

![图片](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKlgt6sanGz3AibMgCBzNl4lWmhAJIIQU91YoWW7sEqAsQUEQ71YAj49I9RzLuPLT9nDMm3Ifb1oQSMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

与select语句相比，因为select没有更新数据，只是将引擎查询的数据返回给执行器就算是完后，而update涉及数据的更新并且重新调用引擎接口写会存储引擎中的交互过程。

### 两阶段提交

上面详细的说了update语句的执行流程，提到了redo log的prepare和commit两个阶段，这就是两阶段提交，两阶段提交的目的是为了保证redo log日志与binlog日志保持数据的一致性。

若是redo log写成功binlog写失败，或者redo log写失败binlog写成功，最后使用这两者日志进行数据恢复得到的结果数据都是不一致性的，所以为了保证两个日志逻辑上的一致，使用两阶段进行提交。

### redo log与binlog的总结

最后来对比一下这两种日志：**redo是物理的，binlog是逻辑的，redo的大小固定，并且以环状的形式写入数据，数据满的时候需要将redo日志中擦除数据，并且将擦除的数据持久化到磁盘中**。

而binlog以追加日志的形式写入，也就是当日志写到一定大小后，就会切换到下一个，并不会覆盖以前写的日志。

binlog是在Mysql的Server层中使用，因为binlog没有crash-safe功能，所以InnoDB引擎自己实现了redo log日志的crash-safe的功能，为了**保证这两个日志逻辑上的一致使用两阶段提交**。

在使用redo和binlog这两种日志的时候，可以将参数`innodb_flush_log_at_trx_commit`和`sync_binlog`都设置为1，它表示每次事务提交的时候，都会将日志持久化到磁盘中。