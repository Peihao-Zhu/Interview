[TOC]







## 1 ★★☆ 连接查询与子查询的比较。



## 2 ★★☆ drop、delete、truncate 比较。

- 作用

  delete：可以删除表中的指定数据

  truncate：清空整个表（把表中的数据都删除）

  drop：把表结构也删除了（删的最彻底）

- 事务

  delete会被放到日志，以便进行回滚

  truncate和drop是立即生效，命令不会存到日志中。

- 删除空间

  delete不会减少表和索引占用的空间

  truncate会将表和索引占用的空间恢复到初始值

  drop会将表和索引所占有的空间释放

- 耗时

  Drop>truncate>delete

## 3 ★★☆ 视图的作用，以及何时能更新视图。

一条查询语句执行后返回的结果集，是一个虚拟表，包含带有名称的行列。但视图中不包含真实的数据，真实数据都在原始表中。

​		**作用**

- 简化复杂的查询，比如复杂的连接查询，在编写查询后，可以方便的重用它还不必知道基本细节。

  ```mysql
  create view productcustomers as
  select cust_name, cust_contact, prod_id
  from customers, orders, orderitems
  where customers.cust_id = orders.cust_id 
  and orderitems.order_num = orders.order_num;
  ```

  该语句创建一个名为productcustomers的视图，连接了三个表来返回购买商品的客户信息。

  ```mysql
  SELECT * FROM productcustomers;
  ```

  通过上面的语句可以重复使用结果，而不需要了解基本的细节。

- 只使用实际表的一部分数据；

- 通过只给用户访问视图的权限，保证数据的安全性；

- 更改数据格式。视图可以返回与底层表格式不同的数据

  假如需要返回的数据格式用到了concat或者其他字符串拼接，不需要每次查询都执行连接，可以创建一个视图，需要的时候直接使用这个视图。如

  ```mysql
  create view vendorlocations as 
  select concat(RTrim(vend_name), '(', RTrim(vend_country), ')') as vend_title 
  from vendors 
  order by vend_name;
  
  ```

  

  

  **何时更新**

  因为视图不存储数据，所以更新视图需要去更新原始表。如果视图定义只依赖于一个原始表，就很容易进行更新操作。但如果视图定义中有以下操作，那么就不能进行视图的更新：

  - 分组查询
  - 连接查询
  - 子查询
  - Union
  - 聚集函数
  - DISTINCT
  - 计算字段

## 4 ★☆☆ 理解存储过程、触发器等作用。

**存储过程**

对一系列SQL操作的批处理。

- 代码封装，保证一定的安全性

- 代码复用

- 预先编译，具有很高的性能

 

**触发器**

触发器在执行以下语句时自动执行：DELETE、INSERT、UPDATE

触发器必须指定在语句执行之前还是之后自动执行，之前执行用BEFORE关键字，之后执行用AFTER关键字。BEFORE用于数据验证和净化，AFTER用于审计跟踪，将修改记录到另外一张表中

## 5 ★★★ B+ Tree 原理，与其它查找树的比较。

B tree 是平衡树，所有叶子节点都在同一层，非叶子节点也可以存储数据，B+ Tree是基于B Tree和叶子结点顺序访问指针实现的，所有数据都存放在叶子结点。可以通过顺序访问提高区间之间查询的性能。 

**m 阶 B 树的性质（m ≥ 2）**

m 阶 B 树指的是一个结点最多拥有 m 个子结点。假设一个结点存储的元素个数为 x，那么如果这个结点是：

- 根结点：1 ≤ x ≤ m - 1
- 非根结点：┌ m / 2 ┐ - 1 ≤ x ≤ m - 1

如果有子结点，子结点个数为 y = x + 1，那么如果这个结点是：

- 根结点：2 ≤ y ≤ m

- 非根结点：┌ m / 2 ┐ ≤ y ≤ m

  

查找时，首先在根节点进行二分查找，然后递归的在key指向的节点进行查找。

与红黑树比较；

（一）B+树高度更低

B+树可以有n个孩子，而红黑树最多只有2个孩子，所以B+树高度更低。

（二）磁盘访问原理

操作系统将内存和磁盘分割成固定大小的块，一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，一次IO就会完全载入一个节点。 

如果数据不在同一个磁盘块上，需要移动制动手臂进行寻道，而制动手臂因为物理结构增加磁盘数据读取时间。B+树相对于红黑树更低，进行寻道次数更少。

（三）磁盘预读特性

为了减少磁盘IO，磁盘往往不是严格按需读取，每次会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，相邻的节点会被预先载入。

## 6 为什么MySQL要使用B+Tree

InnoDB的主键索引还是辅助索引，都是使用B+Tree来存储数据的，主键索引中通过主键id查找所有信息，辅助索引中通过索引值index查找对应的主键id。



#### B+Tree和B Tree、Hash几个结构的比较

在挑选存储数据的结构时基于以下两点来考虑：

- InnoDB 需要支持的场景和功能需要在特定查询上拥有较强的性能；
- CPU 将磁盘上的数据加载到内存中需要花费大量的时间，这使得 B+ 树成为了非常好的选择；

数据持久化和数据查询是很常见的需求，而持久化就要与磁盘、内存和CPU打交道。

**读写性能**

使用B Tree或B+Tree查询数据的复杂度都是在O(logn)，但是Hash查询单条数据可以达到O(1)的复杂度。

不过Hash一旦遇到分组查询，范围查询，排序等操作，只能进行全表扫描.相反B+ Tree 因为结构的特性，本身键是按照顺序存储的，相邻的数据都是自然排序，在以上操作中性能更好

**数据加载**

对于B和B+Tree的区别其实也很简单----计算机在读写文件时会以页为单位将数据加载到内存中。页的大小可能会根据操作系统的不同而发生变化，不过在大多数的操作系统中，页的大小都是 `4KB`，你可以通过如下的命令获取操作系统上的页大小:

```
$ getconf PAGE_SIZE
4096
```

当我们需要在数据库中查询数据时，CPU 会发现当前数据位于磁盘而不是内存中，这时就会触发 I/O 操作将数据加载到内存中进行访问，数据的加载都是以页的维度进行加载的，然而将数据从磁盘读取到内存中所需要的成本是非常大的，普通磁盘（非 SSD）加载数据需要经过队列、寻道、旋转以及传输的这些过程，大概要花费 `10ms` 左右的时间。

我们在估算 MySQL 的查询时就可以使用 `10ms` 这个数量级对随机 I/O 占用的时间进行估算，这里想要说的是随机 I/O 对于 MySQL 的查询性能影响会非常大，而顺序读取磁盘中的数据时速度可以达到 40MB/s，这两者的性能差距有几个数量级，由此我们也应该尽量减少随机 I/O 的次数，这样才能提高性能。

**B 树与 B+ 树的最大区别就是**，B 树可以在非叶结点中存储数据，但是 B+ 树的所有数据其实都存储在叶子节点中，当一个表底层的数据结构是 B 树时，假设我们需要访问所有『大于 4，并且小于 9 的数据』：

![WeChat75437d38134a26d572046377ebf9ebaf](/Users/zhupeihao/Library/Containers/com.tencent.xinWeChat/Data/Library/Caches/com.tencent.xinWeChat/2.0b4.0.9/1ab32f76abfa38116a670b7ac59c1027/dragImgTmp/WeChat75437d38134a26d572046377ebf9ebaf.png)

如果不考虑任何优化，在上面的简单 B 树中我们需要进行 4 次磁盘的随机 I/O 才能找到所有满足条件的数据行：

1. 加载根节点所在的页，发现根节点的第一个元素是 6，大于 4；
2. 通过根节点的指针加载左子节点所在的页，遍历页面中的数据，找到 5；
3. 重新加载根节点所在的页，发现根节点不包含第二个元素；
4. 通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到 7 和 8；

当然我们可以通过各种方式来对上述的过程进行优化，不过 B 树能做的优化 B+ 树基本都可以，所以我们不需要考虑优化 B 树而带来的收益，直接来看看什么样的优化 B+ 树可以做，而 B 树不行。

由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这个特点带来了大量的随机 I/O，也是 B 树最大的性能问题。

B+ 树中就不存在这个问题了，因为所有的数据行都存储在叶节点中，而这些叶节点可以**通过『指针』依次按顺序连接**，当我们在如下所示的 B+ 树遍历数据时可以直接在多个子节点之间进行跳转，这样能够节省大量的磁盘 I/O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能

![image-20200719122108571](/Users/zhupeihao/Library/Application Support/typora-user-images/image-20200719122108571.png)

## 7 ★★★ MySQL 索引以及优化。	

https://blog.csdn.net/qq_39751320/article/details/106280118

 

索引是在存储引擎层实现的，不是在服务器层，所以不同的存储引擎有不同的索引类型和实现。

**索引类型**

1. B+Tree 索引

大多数MySQL存储引擎默认使用B+Tree索引，因为不需要全表扫描，只需要对树进行扫描，查询速度快很多。

B+Tree的有序性，除了用于查找，也可以用于排序和分组

可以指定多个列作为索引列，多个索引列共同组成键

InnoDB的 B+Tree索引分为主索引和辅助索引。主索引的叶子结点记录了完整的数据，称为聚簇索引。辅助索引的叶子结点存放着主键的值，所以使用辅助索引查找时，先查到主键值，然后再去聚簇索引中查找具体的数据。

 

2. 哈希索引 

哈希索引能以O（1）时间查找，但是失去了有序性无法用于排序和分组，只支持精确查找，不能用于部分查找和范围查找。

InnoDB有“自适应哈希索引”，当某个索引值被使用的很频繁时，会在B+Tree索引上在创建一个哈希索引。

 

3. 全文索引

MyISAM存储引擎支持全文索引，用于查找文本的关键字，查找条件是MATHCH AGAINST而不是WHERE 

InnoDB在MySQL5.6.4以后也开始支持全文索引

 

4. 空间数据索引

MyISAM存储引擎支持空间数据索引，用于地理数据存储。需要使用GIS相关函数进行维护和部署

 

**索引优化**

1) 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引

2) 多列索引

使用多个列作为条件进行查询时，使用多列索引比单列索引性能更好。

3) 索引列的顺序

索引的选择性：不重复的索引值和记录的总数比（如果索引值都是不重复的，如主键索引，那么比为1）。选择性越高，每个记录的区分度越高，查询效率也越高。

在组合索引中，将选择性高的索引放在前面。

4) 前缀索引

对于BLOB，TEXT和VARCHAR类型的列，必须使用前缀索引，只索引开始部分字符，前缀的长度根据索引选择性来判断。

5) 覆盖索引

索引包含需要查询的字段的值。

优点：

1.索引通常远小于数据行大小，只读取索引能大大减少数据访问量

2.一些存储引擎（如MyISAM）在内存中只缓存索引，而数据依赖于操作系统缓存。因此，只访问InnoDB引擎，如果辅助索引能够覆盖查询，就不需要访问主索引（不需要回表查询）。

 

索引的优点：

- 大大减少服务器需要扫描的数据行数
- 帮助服务器避免排序和分组以及避免创建临时表（B+Tree是有序的，可以用于ORDER BY和GROUP BY操作）
- 将随机IO变成顺序IO（B+Tree索引是有序的，将相邻的数据存储在一起）

## 8 ★★★ 查询优化。

用Explain分析 select语句，分析比较重要的字段：

- select_type:查询类型，简单查询、联合查询、子查询
- key使用索引
- rows扫描的行数

 

优化数据访问

1. 减少请求的数据量

- 只返回必要的列：最好不要用select *
- 只返回必要的行：使用LIMIT语句来限制返回的数据
- 缓存重复查询的数据

 

2. 减少服务端扫描的行数

使用索引覆盖查询

 

重构查询方式

1) 切分大查询

2) 分解大连接查询

 

## 9 ★★★ InnoDB 与 MyISAM 比较。

**InnoDB**

是默认的**事务型存储引擎**，实现了四个标准的隔离级别，默认是可重复读。在可重复读隔离级别下，通过MVCC+Next-Key Lock防止幻读。

主索引是聚簇索引，在索引中保存数据，从而避免直接读取磁盘，因此对查询性能有很大提升。 

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建自适应哈希索引、能够加速插入操作的插入缓冲区。

支持真正的热备份。其他存储引擎不支持在线热备份，要获取一致性视图需要停止对表的写入，而在读写混合场景，停止写入也会停止读取。 



**MyISAM**

不支持事务

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时会对表加排他锁。在表有读取操作的同时，也可以往表中插入新的记录，被称为并发插入。



**比较**

- 事务；InooDB是事务型，可以使用Commit和Rollback语句
- 并发：MyISAM只支持表级锁，而InnoDB还支持行级锁
- 外键：InnoDB支持外键
- 备份：InnoDB支持在线热备份
- 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复速度也慢
- 其他特性：MyISAM支持压缩表和空间数据索引

**具体实现差异的比较**

1. InnoDB不支持FULLTEXT索引
2. InnoDB不保存具体的行数，selete count() from table InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的独处保存好的行数即可。（如果count语句包含where条件时两者操作一样）
3. 对于AUTO_INCREMENT类型的字段，InnoDB必须包含只有该字段的索引，但是在MyISAM可以和其他字段建立联合索引
4. DELETE FROM TABLE，InnoDB不会重新建立表，而是一行一行删除
5. InnoDB的行锁不是绝对的，如果执行一个SQL语句不能确定要扫描的范围，也是会锁住全表



## 10  ★★☆ 水平切分与垂直切分。	

水平切分：将同一个表中的记录拆分到多个结构相同的表中

垂直切分：将一张表按列切分成多张表，按照列的关系密集程度进行切分，也可以利用垂直切分将经常使用的列和不经常使用的列切分到不同表中

## 11  ★★☆ 主从复制原理、作用、实现。

 	https://blog.csdn.net/weixin_43879074/article/details/88525006

原理：

1.一个bin-log记录所有sql语句

2.把主数据库的bin-log文件的sql语句赋值过来

3.让其在从数据库的relay-log重做日志文件中执行一次这些sql语句

 

作用：

- 实现服务器负载均衡。这里有两种思路

  1）主从服务器负责各自的读和写，主服务器只负责数据的更新，查询任务可以由多台从服务器来完成。提高了数据的安全性，也缩短了应用程序的响应时间、提高系统的性能。

  2）在主服务器上与从服务器切分查询作业，也就是说主服务器不仅要完成数据的更新操作，也需要分担部分的查询作业。而从服务器依旧只负责查询

- 通过主从复制实现异地备份

  ​		在传统的备份体制中，是将数据备份在本地，此时备份作业与数据库服务器运行在同一台设备上，当备份作业运行时会阻塞服务器本身的正常运行，降低其性能。同时将备份数据放在本地也不是很安全，如硬盘损坏或服务器被破坏等。

  ​		主从复制可以在备份的过程中不影响主服务器的正常作业（异步复制）。

- 提高数据库系统的可用性

  ​		主从复制实现了主服务器与从服务器之间的数据同步，如果主服务器出现问题，可以让从服务器作为主服务器实现数据的更新功能，然后检查主服务器的故障。此时还可以进行两种操作

  ​	1）主服务器故障后，虽然从服务器代替了主服务器的位置，但是仍然只能进行数据的查询，这主要是基于安全性考虑。如一些银行系统的升级。

  ​	2）从服务器完全代替主服务器，可以进行数据的更新操作。

 

 

实现：

1.binlog线程：每当有从库连接到主库时，binlog线程将主服务器上的日志更改写入二进制日志（Binary log）

2.IO线程：从库的IO线程连接到主库，从主服务器上读取二进制日志，写入从服务器的中继日志（Relay log）

3.从库的SQL线程：从库创建一个SQL线程，这个线程读取从库IO线程写到relay log的更新数据并重新执行（replay）。

 ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png)



**读写分离**

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因就是上面主从复制的作用

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png)

#### 主从复制可能存在的问题，即解决方法

https://blog.csdn.net/darkangel1228/article/details/80003967

**问题：**

- 主服务器宕机后，数据可能丢失
- 从服务器只有一个sql线程，主库写压力大，复制很可能延时。

**解决方法：**

1. 半同步复制---解决数据可能丢失的问题

   ![这里写图片描述](https://img-blog.csdn.net/20180419134031910?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhcmtBbmdlbDEyMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   原理：

   - 事务在主库写完binlog后发送到从库，需要从库发送ack，主库在返回给客户端；

   - 确保事务提交后至少传到一个从库

   - 并不能保证从库能完成响应操作（接受binlog，写relylog），如果从库宕机或者网络异常的话，主库会一直阻塞，直到超时或者从库恢复

     

2. 并行复制---解决从库复制延迟的问题

   从库设置多个sql线程

   ```mysql
   set global slave_parallel_workers=10;
   ```

   



## 12 ★☆☆ redo、undo、binlog 日志的作用。	

https://blog.csdn.net/u010002184/article/details/88526708

 

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsWR5YnP.jpg) 

 

**一条更新语句执行的顺序**

update T set c=c+1 where ID=2;

 

a. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。

b. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。

c. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

d. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。

e. **执行器调用引擎的提交事务接口**，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

 

**Redo log**

是InnoDB存储引擎层的日志。用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在数据库掉电时，InnoDB会使用redo log恢复到掉电以前的时刻，来保证数据的完整性

 

在更新一条语句时，InnoDB会把更新记录写到redo log中，然后更新内存，然后在空闲的时候或是按照设定的更新策略将redo log中的内容更新到磁盘。**Redo log日志大小是固定的**，即记录满了后就从头循环写。Checkpoint 以前表示已经更新到磁盘的文件，write pos表示当前写的位置，如果两个指针相遇了，表示redo log已经满了，需要同步到磁盘中。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsArv8OA.png) 



每次对记录的修改写入缓冲池的时候，也会写一份redo log（记录者哪一页修改了什么数据），redo log也放在磁盘中，其实也会在内存中有一个buffer，之后再写到redo log中去。可以发现写入redo log也是磁盘IO，但它是顺序IO，比从缓冲池将数据页随机IO到磁盘快很多。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200524181219383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NzUxMzIw,size_16,color_FFFFFF,t_70)

 

**Binlog 日志模块**

binlog属于MySQL Server层面，称为归档日志，以二进制形式记录语句的原始逻辑，binlog是没有crash-safe能力

 

**Redo log和binlog区别**

- Redo log是物理日志，记录数据页更新的内容，binlog是逻辑日志，记录更新语句的原始逻辑
- Redo log是InnoDB层面，binlog是MySQL Server层
- Redo log是循环写，日志空间大小是固定的，binlog是追加写，指一份写到一定大小的时候，会更换文件，而不会覆盖原来的。
- binlog用于主从复制，redo log是作为数据库宕机恢复数据使用的

 

**Undo log**

每条数据修改(insert、update或delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上

## 13 ★★☆  union和union all的区别

https://blog.csdn.net/wanghai__/article/details/4712555

这两个字段都是对查询结果取 **并集**，但是区别是：

- Union不包括重复的行，而union all会包括重复行
- union还会按照默认的规则进行排序，union all不会

具体的例子可以参考前面给出的博客：



**注意：**这里的默认规则是指如果使用select * 则对ID进行排序，如果是select score,name ...则会对score进行排序。当然也可以通过order by来自定义，但是order by字段必须加在最后一个查询语句的后面。

## 14 ★★★ InnoDB如何存储数据

https://www.jb51.net/article/134901.htm

从物理意义上来讲，InnoDB表由共享表空间文件（ibdata1）、独占表空间文件（ibd）、表结构文件（.frm）、以及日志文件（redo文件等）组成。

1. 表结构文件

   在MySQL中建立任何一张表，都会生成.frm文件，用来保存每个数据表的元数据。和存储引擎无关，用来在数据库崩溃时恢复表结构。

2. 表空间文件

   （1）表空间结构分析

![img](https://img.jbzj.com/file_images/article/201802/20182101417001.jpg)

数据段即B+树的叶子节点，索引段即为B+树的非叶子节点，InnoDB存储引擎的管理是由引擎本身完成的，表空间（Tablespace）是由分散的段(Segment)组成。一个段(Segment)包含多个区（Extent）。

区（Extent）由64个连续的页（Page）组成，每个页大小为16K，即每个区大小为1MB，创建新表时，先使用32页大小的碎片页存放数据，使用完后才是区的申请（InnoDB最多每次申请4个区，保证数据的顺序性能）
页类型有：数据页、Undo页、系统页、事务数据页、插入缓冲位图页、以及插入缓冲空闲列表页。

​		（2）独占表空间文件

若将innodb_file_per_table设置为on，则系统将为每一个表单独的生成一个table_name.ibd的文件，在此文件中，存储与该表相关的数据、索引、表的内部数据字典信息。

​		（3）共享表空间文件

在InnoDB存储引擎中，默认表空间文件是ibdata1（主要存储的是共享表空间数据），初始化为10M，且可以扩展，使用共享表空间存储方式时，Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。

而在使用单独表空间存储方式时，每个表的数据以一个单独的文件来存放，这个时候的单表限制，又变成文件系统的大小限制了。

​		（4）共享表空间和独占表空间

共享表空间：一个数据库的所有表数据，索引文件都在一个文件中，默认文件路径在data目录下，默认文件名为ibdata1 初始化为10M

独占表空间：每个表都会生成独立文件方式来进行存储（.ibd文件包括了表数据和索引内容）

- 存储内容：使用了独占表空间以后，每个表的数据、索引和插入缓冲放在独占表空间；每个表的撤销信息、系统事务、二次写缓冲还是存放在共享表空间

- 特点比较

  **共享表空间**

  优点：数据文件方便管理；表空间可以分成多个文件放在各个磁盘中

  缺点：数据和索引放在一个表中，，对一个表做大量删除操作后表空间会有大量的空隙

  **独占表空间**

  优点：不管怎么删除，表空间的碎片不会严重影响性能。

  缺点：单表体积可能过大，超过100G

## MySQL的自增ID用完了怎么办

将id设为int unsigned 最大为2^32-1=4294967295，那么如果初始设置id的auto_increment为这个值，之后在执行插入操作会怎么办呢？

```mysql
17:28:03    insert into t1 values(null) Error Code: 1062. Duplicate entry '4294967295' for key 'PRIMARY'    0.00054 sec
```

会报异常，在插入的时候，自增ID还是4294967295，报主键冲突错误。这个数字已经很大，能应付大部分场景，如果经常要执行插入和删除数据的操作，可以采用bigint unsigned。

**如果创建表的时候没有申明主键，会怎么办？**

InnoDB会自动创建一个6字节的隐式主键row_id，所有未定义主键的表都共享这个row_id。该全局ro w_id使用了bigint unsigned类型，但是只给了6字节，如果ro w_id涨到了2^48-1之后在插入数据也会存在主键冲突的风险。

所以为了避免这种隐患，每个表都定义一个主键