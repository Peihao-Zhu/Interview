# 1 基础

## 1.1 ★★★ 各层协议的作用，以及 TCP/IP 协议的特点。	

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsvMjgoL.jpg)

####  五层协议

- 应用层：为特定应用程序提供数据传输服务，如HTTP、DNS。数据单位为报文
- 传输层：为进程提供通用数据传输服务。运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP提供完整性服务，UDP提供及时性服务。
- 网络层：为主机提供数据传输服务。把传输层传下来的报文段或者用户数据报封装成分组
- 数据链路层：主机之间有很多链路，链路层协议就是同一链路的主机提供数据传输服务
- 物理层：怎样在传输媒体上传输数据比特流，而不是具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异

#### TCP/IP协议的特点

https://blog.csdn.net/qq_33857502/article/details/57414162

（1）TCP/IP协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准，即使不考虑Internet，TCP/IP协议也获得了广泛的支持。所以TCP/IP协议成为一种联合各种硬件和软件的实用系统。

（2）TCP/IP协议并不依赖于特定的网络传输硬件，所以TCP/IP协议能够集成各种各样的网络。用户能够使用以太网（Ethernet）、[令牌环网](http://baike.baidu.com/view/115033.htm)（Token Ring Network）、拨号线路（Dial-up line）、[X.25](http://baike.baidu.com/view/175390.htm)网以及所有的网络传输硬件。

（3）统一的网络地址分配方案，使得整个TCP/IP设备在网中都具有惟一的地址

（4）标准化的高层协议，可以提供多种可靠的用户服务。

## 1.2 ★★☆ 以太网的特点，以及帧结构。	

以太网是一种星型拓扑结构的**局域网**，早期使用集线器进行连接，作用于比特而不是帧，当一个比特到达接口时，集线器生成该比特并将其强度放大，从而扩大网络距离。

 

现在以太网使用交换机替代了集线器，交换机是一种链路层设备，不会发生碰撞，会根据MAC地址进行存储转发

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsi4HsWs.jpg) 

- 类型：标记上层使用的协议
- 数据：长度在46-1500之间
- FCS：帧检验序列，使用CRC（循环冗余）检验

## 1.3 ★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。	

https://blog.csdn.net/clubsondy/article/details/542615

 

**集线器：**

物理层

没有智能处理能力，数据只是电流而已，当一个端口的电流传到集线器中时，只是简单的将电流传送到其他端口，至于其他端口连接的计算机接不接收就不管了。

共享性模式，就是一个端口在向另一个端口发送数据时，其他端口处于等待状态。

 

**交换器：**

链路层

具有自学习能力，学习得是交换表的内容，交换表中存储着MAC地址到接口的映射。因为是自学习，所以交换机是一种即插即吧设备，不需要管理员手动配置交换表内容。

下图：交换机有4个接口，主机A向主机B发送数据帧时，交换机把主机A的MAC的地址和接口1的映射写入交换表，此时没有主机B的表项，所以主机A发送广播帧，主机C和主机D会丢弃该帧，主机B回应该帧向A发送数据包时，交换机查找交换表得到主机A映射的接口为1，发送数据到接口1，同时在交换表中添加主机B的MAC地址到接口2的映射。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsqd1GT5.jpg) 

 

**路由器：**

工作在网络层，能够连接不同类型的网络，能够选择数据传送的路径。能理解数据中的IP地址，如果接收到一个数据包，就检查其中的IP地址，如果目标地址是本地网络，就不理会，如果是其他网络，就会将数据包转发出本地网络。

集线器和交换机一般用于连接以太网，路由器可以连接不同类型的局域网，广域网。不同类型的网络，传送的数据单元-帧的格式大小也不同。

路由器有路径选择能力，从一个节点到另一个节点有不同的路由算法。

## 1.4 ★★☆ IP 数据数据报常见字段的作用。	

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsmLk9gI.png) 

- 版本：IPv4和IPv6
- 首部长度：占4个位，最大值位15.值为1表示1个32位长度，也就是4字节。因为固定部分长度位20字节，所以该值最小位5
- 区分服务：用来获得更好的服务，一般不用
- 总长度，包括首部长度和数据部分长度
- 生存时间TLL：防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数位单位，当TLL为0就丢弃数据包。
- 协议：携带的数据上交给哪个协议进行处理，如ICMP、TCP、UDP。
- 首部检验和：数据包每经过一个路由器，都要重新计算检验和，检验和不包含数据部分可以减少计算量
- 标识：在数据报过长而发生分片情况下，相同数据报的不同分片具有相同的标识符
- 片偏移：和标识符一起，用于发生分片的情况。单位是8字节。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsNcZp1d.jpg) 

## 1.5 ★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。

**ARP实现由IP地址得到MAC地址。**

网络层实现主机间的通信，而链路层实现具体每段链路之间的通信。在通信过程中，IP数据报的原地址和目的地址不变，而MAC地址会随着链路的改变而改变。

每个主机都有一个ARP高速缓存，里面有局域网上各主机和路由器IP地址到MAC地址的映射表。

如果主机A知道主机B的IP地址，但是ARP高速缓存没有该IP地址到MAC地址的映射，就会通过**广播方式向所在的发送ARP请求分组**，这个请求分组中会包括原IP地址到其MAC地址的映射；主机B收到该请求后会首先保存这一对映射，然后发送ARP响应分组给主机A，告知其MAC地址，随后主机A向高速缓存写入主机B的IP地址到MAC地址的映射，要是主机A一直瘦不发哦响应，表示ARP查询失败。如果这个主机不再他的局域网内，那么需要通过ARP找到位于本局域网上的某个路由器的硬件地址，然后把分组发送给路由器，让这个路由器分组转发给下一个网络。剩下的工作由下一个网络来做。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsw0YOzk.jpg)

## 1.6 ★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。	

ICMP是为了检测网络通信故障和实现链路追踪，被封装在IP数据报中。最典型的应用是PING和traceroute。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsW1FnkG.png) 

 

ICMP种类：差错报告报文和询问报文

 

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsEiTAI6.jpg) 

 

#### 1.Ping

测试两台主机的联通性，Ping的原理是通过向目的主机发送ICMP echo请求报文，目的主机收到后发送Echo回答报文。Ping会根据时间和成功响应的次数估算出数据报往返时间以及丢包率。

 

#### 2.Traceroute

用来跟踪一个分组从源点到终点的路径。Traceroute发送的IP数据报封装的是无法交付的UDP用户数据报，并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的IP数据报。第一个数据报P1的生存时间TTL为1，当P1到达路径上第一个路由器R1是，就把他丢弃，并向源主机发送一个ICMP时间超过差错报告报文。
- 源主机接着发送第二个数据报P2，并把TTL设置为2，P2先到达R1，R1收下后把TLL减1在转发给R2，R2收下后TTL为0，把它丢弃，并向源主机发送一个ICMP时间超过差错报文。
- 不断执行这个步骤，直到数据报刚刚到达目的主机（目的主机不会转发数据报，不会吧TTL值减1，但是数据报封装的是无法交付的UDP，所以目的主机向源主机发送ICMP终点不可达差错报告报文），之后源主机就知道了目的主机所经过的路由器IP地址以及到达每个路由器的往返时间

## 1.7 ★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。	

#### TCP的UDP的区别

1. TCP是面向连接的，UDP是无连接的

2. TCP是可靠的，UDP是不可靠的

3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；

4. **TCP是面向字节流的，UDP是面向报文的**

（面向字节流指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送；UDP只能一个报文一次发完）

5. TCP有拥塞控制机制，UDP没有。

6. TCP首部开销（20字节）比UDP（8字节）大

7. UDP的主机不需要维持复杂的连接状态

  

 

**UDP（用户数据报协议）**：无连接的，尽最大可能交付，没有拥塞控制（对实施性应用很重要），面向报文（对应用程序传下来的报文不合并也不拆分，只是添加UDP首部），支持一对一、一对多、多对一和多对多通信。首部8个字节

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpscziFWF.png) 

 

 

**TCP（传输控制协议）**：面向连接，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看出字节流），TCP只能是点对点的通信。首部20个字节

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsEd7275.jpg) 

 

 

#### TCP和UDP应用场景：

对实时性要求比较高的情况，选择UDP，如游戏，通信，实时视频流，即使出现传输错误也是可以容忍的；其他大部分情况，HTTP都是使用TCP

 

HTTP不能使用UDP，因为UDP是不可靠的，而HTTP是基于可靠的传输协议

 

使用UDP的应用层协议有：DNS（域名系统）、TFTP（简单文件传送协议）、RIP（路由信息协议）、DHCP（动态主机配置协议）、SNMP（简单网络管理协议）、NFS(网络文件系统)、IGMP（忘记组管理协议），此外在网络语音或视频通信中也使用UDP通信

 

使用TCP的应用层协议有：HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、TELNET（远程终端协议）

 

**面向连接和无连接的区别。**

- 无连接的网络服务（数据报服务）：

每个数据包含目的地址，数据路由相互独立；网络经最大努力交付数据，但不保证送达、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能将一些分组丢弃。

- 面向连接的网络服务（虚电路服务）

首先建立连接，所有的数据包经过相同的路径服务质量有较好的保证

## 1.8 ★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。

### 三次握手

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpszrqVhY.jpg) 

1. 第一次握手：Client将SYN=1 ACK=0，随机产生一个初始序列号x发送给Server，进入SYN_SENT
2. 第二次握手：Server收到Client的SYN=1以后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=x+1，并随机产生一个初始序列号y，发送给客户端，进入SYN_RCVD状态
3. 第三次握手：Client检查acknowledge number是否为序列号+1，ACK是否为1，检查正确后将ACK置1，产生一个acknowledge number=y+1,序列号为x+1，发送给服务器；进入Established状态；服务器检查ACK为1和acknowledge number=y+1，也进入Established状态,连接建立

 

#### 问TCP建立连接可以两次握手吗

 

不可以 有两个原因：

1.可能出现已失效的连接请求又传到了服务器端

client发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留了，以至到连接释放以后的某个时间才到达server。本身这已经是一个失效的报文段。但是server接受到此请求以后还以为是新的连接请求，于是向client发出确认报文，同意建立连接。如果采用两次握手，那么只要server确认，新的连接就建立了。由于client并没有发出建立连接的请求，所以不会理睬server，也不会向server发送数据，但是server却发出了建立连接的请求，并一直等待client的回复。这样server的很多资源就浪费了。

2.两次握手无法保证client正确收到第二次握手的报文（server端不知道），也无法保证client和server之间成功互换初始序列号

 

#### 可以采用四次握手吗

 

可以。但是会降低传输效率

四次握手是指在第二次握手时server只发送ACK和acknowledge number；而Server的SYN和初始序列好在第三次握手中发送。处于优化的目的，四次握手的二、三可以合并。

 

#### 第三次握手中，如果客户端的ACK未送达服务器，会怎样？

Server端；

由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），client收到后会重新传ACK给server。

Client端，有两种情况：

1.在Server超时重发的过程中，如果CLient发送的数据，ACK为1，所以服务器收到数据后就进入extablished状态

2.在Server已经进入closed状态后，Client在向服务器发送数据，服务器会以RST包应答。

 

#### 如果已经建立了连接，但客户端出现了故障怎么办？

服务器每收到一次客户端的请求后都会复位一个计数器，时间通常设置2小时，若2小时还没有收到客户端数据，服务器会发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文段都没有反应，服务器就会关闭连接。

 

#### 初始序列号是什么？

TCP的连接一方A，随机选择一个32位序列号作为发送数据的初始序列号（Initial Sequence Number，ISN），比如100，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。

 

### 四次挥手

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsnOTuFJ.png) 

 

1. 第一次挥手：Client将FIN置1，发送一个seq给Server；进入FIN——WAIT——1状态
2. 第二次挥手：Server收到FIN，发送一个ACK；进入CLOSE_WAIT状态。此时客户端没有要发送的数据，但仍可以接受服务器发送的数据
3. 第三次挥手：Server将FIN置1，发送一个seq给Client；进入LAST_ACK状态
4. 第四次挥手：Client收到FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1；服务器收到后确认acknowledge number，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL(报文段最长寿命)，也进入CLOSED状态，完成四次挥手。

 

#### 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSED_WAIT状态的意义）

当服务器收到客户端断开连接的请求时，可能数据还没发送完，所以回复ACK，表示接收到断开连接的请求。等到数据发完后在发FIN，断开和服务器的数据传输。

 

#### 如果第二次挥手时服务器的ACK没有送达客户端会怎样

客户端没有收到ACK，会重新发送FIN请求

 

#### 客户端的TIME_WAIT状态意义是什么

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由.

1.确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生.

2.等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文(防止客户端提前结束的话，服务器端会重复发送FIN报文)。

**MSL(Maximum Segment Lifetime)**，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

## 1.9 ★★★ 可靠传输原理，并设计可靠 UDP 协议	

https://blog.csdn.net/pangyemeng/article/details/50387078

 

### TCP实现可靠传输的原理

数据包检验、确认机制（对失序数据包重排序，接收到数据后，会发送一个确认）、超时重传机制、滑动窗口，流量控制

**1.数据包校验**

发送方将伪首部、TCP首部、TCP数据 使用累加和检验的方式计算出一个数字，存放在TCP首部的校验和字段中。接受方使用经过同样的过程计算校验和与首部该字段的值进行比较，如果不一致就说明数据传输错误。

但是即使校验和相同，也不能保证数据是准确的，因为累加和校验本身就存在缺陷，很可能两个位置的数据交换以下，校验结果还是正确的。所以为了安全可以在应用层增加额外的数据校验方式（使用MD5加密）。

**2.超时重传**

如果一个已经发送报文段在一段时间内没有收到确认，就会重传这个报文段。

详细机制：

TCP协议会设立重传定时器，在发送一个报文段的同时启动重传定时器，如果在重传定时器超时前收到了确认报文就关闭该定时器；反之就会重传该报文段。在重传时间的设定上，TCP具有自适应性，会根据当前互联网的通信情况，给出合适的重发时间。对于重传定时器的初值设定较多采用Jacobson的算法。。。。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsd4iDE7.jpg) 

 

**3.确认机制**

TCP能确保每个数据段都到达目的地，实现方式是目的主机在接收到数据后会发送确认消息。

举例：

如果发送报文段时序列号是1000，传输的连续数据段有100个，当目的主机接受了这100个数据以后会发送确认消息，此时的acknoeledge number=1000+100+1=1101，表示期待接受的下一个字节（期待确认）

**4.滑动窗口**

窗口是缓存的一部分，发送方和接收方都有，用来暂时存放字节流。接收方会通过TCP报文段中的窗口字段告诉发送方自己的窗口大小。

 

**发送窗口**包括已发送但尚未收到确认的数据和允许发送但尚未发送的数据，如果有数据收到了确认，窗口就会右移。

**接受窗口**只会对<u>最后一个按序到达的字节进行确认</u>，例如接受窗口收到字节{31,34,35},只会接受{31},只对31进行确认。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsMe57H0.png) 

 

 

### 设计可靠的UDP协议

传输层无法保证数据的可靠传输，通过应用层来实现，实现的方式就按照上面讲的三个实现可靠传输的机制：确认机制、超时重传机制、滑动窗口；

1.添加seq/ack机制，确保数据发送到目的端

2.添加发送和接受缓冲区，

3.添加超时重传机制

## 1.10 ★★☆ TCP 拥塞控制的作用，理解具体原理。

https://blog.csdn.net/m0_37962600/article/details/79993310?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

#### 作用： 

防止过多的数据注入到网络中，使路由器或链路过载。

 

#### 拥塞控制原理：

通过四个算法来实现TCP拥塞控制：慢开始、拥塞避免、快重传、快恢复。

发送方维护一个拥塞窗口(cwnd)状态变量，发送方窗口决定了实际发送方能发送多少数据。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/910f613f-514f-4534-87dd-9b4699d59d31.png)

**1.慢开始**

最初令cwnd=1，发送方开始只能发送一个报文段；当收到确认后，将cwnd加倍。因此之后发送方能发送的报文使2、4、8...

 

当rwnd足够大的时,即接收方有足够大的接受缓存，不会发生流量控制，为了防止cwnd的增长引起网络阻塞，需要设置一个慢开始阈值(ssthresh)

- 当cwnd<ssthresh 使用慢开始算法
- 当cwnd>ssthresh 停止使用慢开始，使用拥塞避免算法

 

**局限性：**

需要获得网络内部流量分布信息，浪费可用的网络容量，额外开销；估算合理的ssthresh不容易

注意：

1）接收端窗口rwnd，又称通知窗口awnd，使接收端根据目前的接受缓存大小允许的最新窗口值，是来自接收端的流量控制

2）拥塞窗口cwnd使发送端根据其估计的网络阻塞程度而设置的窗口值，来自发送端的流量控制

3）cwnd初始可以设置为一个报文段(实质是TCP数据包每次能够传输的最大数据分段，不包括TCP首部，只出现在SYN报文段中)

 

**2.拥塞避免**

每经过一个往返时间RTT，让cwnd+1

无论是慢启动还是拥塞避免，一旦出现拥塞(发送超时),就把ssthresh设置为cwnd的一半，然后cwnd重新设为1，进行慢开始，这样能迅速减少网络中的数据传输。拥塞窗口是按照线性规律增长。

 

AIMD（加法增大乘法减小）：乘法减小：网络发现超时，就将ssthresh减少一半，cwnd为1；加法增大：cwnd缓慢增大，以防网络过早拥塞

 

拥塞避免算法不能完全避免拥塞，只能使网络不容易产生拥塞。

 

**3.快重传（重传失序报文）**

在接收方，要求每次接收到的报文段都对最后一个已收到的有序报文段进行确认。

在发送方如果收到三个重复确认（不用等到重传计时器到期），就知道下一个报文段丢失，此时执行快重传。

如下图M3发生丢失，所以连续收到3个M2，立即重传M3

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsqXy6eb.jpg) 

 

**4.快恢复**

当收到三个重复确认后，ssthresh=cwnd/2，cwnd=ssthresh,直接进入拥塞避免。

#### 为什么收到三个重复确认后，是直接进入拥塞避免而不是慢开始？

因为这种情况下有三个重复确认，表示当前网络环境是好的，不断有数据报送达，所以网络没有拥塞，没必要慢开始，可以直接执行拥塞避免。也有些把cwnd设置为ssthresh+3*MSS,因为既然已经收到了3个重复确认，表示这三个分组不再消耗网络资源，而是停留在接收方的缓存中，可以把拥塞窗口扩大些。

 

**注意：**

慢开始和快恢复指的是cwnd的值，并不是cwnd的增长率，慢开始设为1，而快恢复设为ssthresh

## 1.11 ★★☆ DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。	

DNS端口号53 当长度超过512字节使用TCP。

- DNS区域传输使用TCP协议：

次域名服务器会定时向主域名服务器进行查询以了解数据是否变动。如有变动，会执行一次区域传送，进行数据同步，使用TCP，因为数据同步传送的数据量比一个请求应答的数据量要多的多。并且TCP是可靠传输，保证数据的准确性。

- 域名解析使用UDP协议：

客户端向DNS服务器查询域名，一般返回的内容不超过512字节（如果超过了，会截断，那么用户得到的DNS应答是不完整的），用UDP传输，不用三次握手，这样DNS服务器负载更低，响应更快。理论上说客户端也可以指定向DNS服务器查询时用TCP，但事实上很多DNS服务器配置时，仅可以UDP查询。

 

**如果想要UDP传送超过512字节的数据，可以在DNS字段中增加报文ID，用于分片**

 

## 1.12 ★★☆ TCP如何实现流量控制	

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsl1XCDr.jpg) 

TCP首部中有一个窗口字段--占2个字节。用来控制发送方发送的数据量。接受方根据自己的缓存空间大小确定接受窗口的大小。

使用**滑动窗口协议**实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接受窗口，在返回ACK时，会将接受窗口的大小放在TCP报文的窗口字段中。

发送窗口的上限为接收窗口和拥塞窗口中的较小值。

 

#### 什么是零窗口（接收窗口为0会怎么样）？

如果接受方没有能力接受数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计数器，到期后发送一个大小为1字节的探测数据报，以查看接受窗口的状态。如果接收方能接受数据买就会在返回报文中更新接受窗口大小，恢复数据传送。

##  

# 2 HTTP

## 2.1 ★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。

1. 幂等性：GET是 幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的

2. 作用：GET一般从服务器获取资源，而POST有可能改变服务器上的资源

3. 参数：GET请求的数据附在URL之后，HTTP请求头中；POST请求的数据在请求体中

4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会保存，安全性相对较高

5. GET只允许ASCII字符，而POST对数据类型没有要求，也允许二进制数据

6. GET的长度有限制（操作系统或浏览器），POST没有限制

 

注意：幂等性指作用于结果而非资源本身，就是说返回的内容可能不同，但是不会影响（修改）资源。

## 2.2 ★★☆ HTTP 状态码。

- 2xx状态码：操作成功。

200 OK ；

204 No Content 请求处理成功，但返回的响应报文不包含实体的主题内容。一般只需要从客户端往服务器发送消息，不需要服务器返回信息。

- 3xx状态码：重定向。

301 永久重定向；

302暂时重定向

- 4xx状态码：客户端错误。

400 Bad Request（请求报文中存在语法错误）；

401 Unauthorized（发送的请求需要有认证信息）；

403 Forbidden；

404 Not Found；

- 5xx状态码：服务端错误。

500服务器内部错误；

503服务不可用（服务器暂时处于超负荷正在停机维护）

 

## 2.3 ★★★ Cookie 作用、安全性问题、和 Session 的比较。

https://blog.csdn.net/resilient/article/details/85249842

 

HTTP协议是无状态的，HTTP/1.1引入Cookie保存状态信息。Cookie是服务器发送到用户浏览器并保存到本地的一小块数据，他会在浏览器向同一服务器再次发送请求时被携带上。由于每次请求都会携带Cookie数据，因此会带来额外的开销。

**作用：**

- 会话状态管理（用户登陆状态、购物车、游戏分数或其他需要记录的信息）
- 个性化设置
- 浏览器行为跟踪

**安全性问题：**

cookie存储在浏览器端，可以通过脚本或者工具抓去获取该值。

可以通过javascript的 document.cookie来获取Cookie。可以将Cookie标记为HttpOnly，就不能被JavaScript脚本调用。一定程度上避免跨站脚本攻击XSS。标记Secure的Cookie只能通过被HTTPS协议加密过的请求发送给服务端。但即便设置了Secure标记，敏感信息也不应该通过Cookie传输，因为有其固有的不安全性

1.Cookie欺骗：获取cookie以后虽然不知道其含义，但是可以将这个cookie向服务器提交，冒充用户来访问进而获取隐私信息。

2.Cookie截获：cookie以纯文本的形式在浏览器和服务器之间传递，在web通信时很容易被非法用户截获。

3.Flash的内部代码隐患：在观看Flash动画是，其内部可能悄无声息的打开了极小的不易发现的页面，可以向远程服务器输入当前cookie用户信息。

**解决办法：**

1.cookie有效期不要设置过长

2.设置HttpOnly属性为true

3.设置复杂的cookie，加密cookie（key用uuid随机生成，value使用复杂组合如用户名+当前时间+cookie有效时间+随机数）

4.用户第一次登录时，保存ip+cookie加密后的token

5.seesion和cookie同时使用

6.如果网站支持https，尽可能使用https（设置cookie的Secure属性为true）

 

**Session**

存储在服务器，存储在服务器端更安全。可以存放在数据库或内存或者Redis中。

使用session维护用户登陆状态的过程如下

1. 用户进行登陆时，用户提交包含用户名和密码的表单，放入HTTP请求报文中
2. 服务器验证该用户名和密码，如果正确就把用户信息存储到Redis中，Key就是SessionID；
3. 服务器返回的响应报文的Set-Cookie首部字段包含了这个Session ID，客户端收到响应报文后将该Cookie值放入浏览器
4. 客户端之后对同一个服务器进行请求时都包含该cookie值，服务器收到后提取SessionID，从Redis中提取用户信息，继续之前的业务操作。

 

**Cookie和Session比较**

Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案

Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。

Cookie只能存储ASCII，Session可以存储任何类型数据

Cookie不要存储隐私数据

大型网站，用户所有的信息都存储在Session中，开销是非常大的，不建议将所有用户信息存储到Session中。

## 2.4 ★★☆ 缓存 的 Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。

**优点：**

- 缓解服务器的压力
- 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快；并且缓存服务器的位置通常比源服务器更新，比如浏览器缓存。

### Cache-Control 

HTTP/1.1 通过Cache-Control首部字段控制缓存。

1. 禁止进行缓存 no-store 规定不能对请求或响应的任何一部分进行缓存

2. 强制确认缓存 no-cache 缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效是才能使用该缓存对客户端的请求进行响应

3. 私有缓存和公共缓存  

   private：将缓存作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中 ；

   public ：规定资源作为公共缓存，可被多个用户使用，一般存储在代理服务器中

4. 缓存过期机制 

   max-age（相对日期，多少秒后过期）

- 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就接受该缓存
- 出现在响应报文中，表示缓存在服务器中保存的时间 

​		Expires（绝对日期，年月日小时...）

- Expires首部字段可用于告知缓存服务器该资源过期时间



HTTP/1.0，max-age会被忽略掉

HTTP/1.1，max-age会优先处理

如果服务器和客户端不同时间，还是采用max-age相对日期更好，因为两个采用的时间不一样

 

### ETag---缓存验证

ETag是资源的唯一标识符，URL不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源。

可以将缓存资源的ETag放入If-None-Mathch首部，服务器收到该请求后，判断缓存资源的ETag值和资源的最新ETag值是否一致，如果一致则表示缓存资源有效，返回304 Not Modified

Last-Modified首部字段也可以用于缓存验证，他包含在源服务器发送的响应报文中，表示源服务器对资源的最后修改时间。但是它是一种弱校验，只能精确到1秒，所以经常作为ETag的备用方案。如果响应首部字段里含有这个信息，客户端在后续的请求中会带上If-Modified-Since来验证缓存。服务器只在自己的Last-Modified 比 客户端请求的If-Modified-Since 晚才会返回最新的资源（**换句话说就是客户端发送请求的时候，服务器的缓存已经修改过了**），状态吗是200OK。如果请求的资源从那时起没有修改，就返回一个304Not Modified响应报文。

```html
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT

If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

 

## 2.5 ★★★ 长连接与短连接原理以及使用场景，流水线。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/HTTP1_x_Connections.png)

- HTTP/1.0默认是短连接的，如果需要使用长连接，则使用Connection：Keep-Alive。适用于数据库连接
- HTTP/1.1默认是长连接的，如果要断开连接，需要客户端或者服务器端提出断开，使用Connection：close;
- 默认情况下HTTP是按顺序发出的，下一个请求只有在收到响应后才会发出。但由于收到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，需要等待很长时间。流水线在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

## 2.6 ★★★ HTTP 存在的安全性问题，和HTTPS的区别以及 HTTPs 的加密、认证和完整性保护作用。

HTTP的安全性问题

1. 使用明文通信，内容可能被窃听

2. 不验证通信方的身份，通信方可能被伪造

3. 无法证明报文的完整性，报文可能遭篡改

 

HTTP与HTTPS区别

1.端口不同：HTTP使用80端口，HTTPS使用443端口

2.HTTP是明文传输，HTTPS运行在SSL（Secure Socket Layer），添加了加密和认证机制

3.HTTPS由于加密解密会带来更大的CPU和内存消耗

4.HTTPS通信需要证书，一般需要向证书颁发机构购买。

 

HTTPS的连接过程

1.客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；

2.服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书私钥只能用于服务器端加密）

3.客户端验证服务器的合法性，包括：证书是否过期，CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。

4.如果证书受信任，或者用户接受了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手信息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器。

5.服务器用自己的私钥解密，得到对称算法的密钥，用这个密钥解密出Hash摘要值，并验证握手信息是否一致；如果一致，服务器使用对称加密的密钥加密握手信息发送给浏览器。

6.浏览器解密并验证摘要，若一致，则握手结束。之后数据传送都是用对称加密的密钥进行加密。

 

**其中第二步使用了 证书 对通信方进行认证**

数字证书认证机构(CA ,Certificate Authority)是客户端与服务器双方都可信赖的第三方认证机构。

服务器运营人员向CA提出公开密钥的申请，CA在判明提出申请者的身份后，会对已申请的公开密钥做数字签名，然后分配这个公开密钥，并将公开密钥放入证书后绑定。

在HTTPS通信时，服务器会把证书发送给客户端。客户端取得公钥后，使用数字签名进行验证，验证通过就可以开始通信。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wps6igqrW.jpg) 

 

**完整性保护**

SSL提供报文摘要功能进行完整性保护

 

HTTP也提供MD5报文摘要功能，但不安全。例如报文内容被篡改后，同时重新计算MD5的值，通信方是无法意识到发生了篡改。

 

HTTPS的报文摘要功能之所以安全，是因为它结合加密和认证这两个操作。

 

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpszWsxXy.jpg) 

 

总结：非对称加密算法用于在握手过程中能加密生成的密钥；对称加密算法用于对真正传输的数据进行加密；Hash算法用于验证数据的完整性

 

**你访问的网站是如何自动切换到HTTPS的**

https://www.sohu.com/a/136637876_487516

1.一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS，但这样又一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。

2.使用HSTS机制。（HTTP Strict Transport Security）

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wps5bQb3j.jpg) 

用户浏览器一旦得到HSTS的信息，下次再访问站点的时候客户端浏览器就会强制使用HTTPS，无论在地址栏里输入什么，都会以HTTPS访问。



 

**什么是对称加密、非对称加密？区别是什么？**

- 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4
- 非对称加密：需要两个密钥：公钥和私钥。如果公钥加密，需要用私钥才能解密。如RSA
- 区别：对称加密速度快，通常用于大量数据的加密；非对称加密的安全性更高（不需要传送私钥）

 

**数字签名、报文摘要的原理**

发送者A用私钥进行签名，接受者B用公钥验证签名。

摘要算法：MD5、SHA

 

**HTTPS缺点**

l 需要进行加密和解密过程，速度更慢

l 需要支付证书授权的高额费用

## 2.7 ★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点。

### HTTP/1.x的缺点

HTTP/1.x 实现简单是以牺牲性能为代价的

- 客户端需要使用多个连接才能实现并发和缩短延迟
- 不会压缩请求和响应首部，从而导致不必要的网络流量
- 不支持有效的资源优先级，致使底层TCP连接的利用率低下

 

#### 二进制分帧层

HTTP/2.0将报文分成HEADERS帧和DATA帧，他们都是二进制格式

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wps9Qt208.jpg) 

通信时只有一个TCP连接，这个连接里有**任意数量的双向数据流**

- 一个数据流都有唯一标识符和可选的优先级信息，用于承载双向信息。
- 消息是与逻辑请求或响应对应的完整的一系列帧
- 帧是最小的通信单位，来自不同数据流的帧可以交错发送，然后根据每个帧头的数据流标识符重新组装

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png)

#### **服务端推送**

HTTP/2.0在客户端请求一个资源时，会把相关资源一起发送给客户端，客户端就不需要在次发送请求了。

 

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsACWWwA.jpg) 

 

#### **首部压缩**

HTTP/1.1的首部带有大量信息，而且每次都要重复发送

HTTP/2.0要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免重复传输

HTTP/2.0使用Huffman编码对首部字段进行压缩

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png)

## 2.8 ★★★ HTTP/1.1 的特性。

- 默认是长连接的
- 支持流水线
- 支持同时打开多个TCP连接
- 支持虚拟主机
- 新增状态码100
- 支持分块传输编码
- 新增缓存处理指令 max-age

## 2.9 ★★☆ HTTP 与 FTP 的比较。

https://blog.csdn.net/only_musm/article/details/78983364

**相同点：**

1.都是应用层协议

2.都运行在TCP上

 

**不同点：**

1.HTTP是超文本传输协议，是面向网页的；FTP是文件传输协议，是面向文件的

2.HTTP协议默认端口：80；FTP：21端口发送控制连接，20端口发送数据连接

3.FTP控制信息是带外传送，而HTTP控制信息是带内传送的

4.FTP服务器必须在整个会话期间保留用户的状态信息，而HTTP是无状态的。

FTP服务器必须把特定的用户账户与控制连接信息联系起来，随着用户在远程目录树上移动，服务器必须追踪用户在远程目录树上的当前位置。对每个活动的用户会话状态进行追踪，可以对FTP会话总数进行限制。

5.FTP的控制连接是持久连接，数据连接是非持久连接；而HTTP既可以是非持久连接，也可以是持久连接，默认是持久连接，FTP有两种工作方式：

两种方式的控制链路连接过程是一样的，都是客户端向服务器的FTP端口（21）发送连接请求，服务器接受连接后建立控制连接链路。

- PORT（主动式）工作方式：客户端在控制连接链路上用PORT命令告诉服务器“我打开了xxx端口，来连接我”：。于是服务器从20端口向客户端xxx端口发送连接请求，建立数据连接链路传送数据。
- FTP的PASV（被动式）工作方式：服务器在控制链路上用PASV命令告诉客户端“我打开了xxx端口，你来连接我”于是客户端向服务器的xxxx端口发送连接请求，建立一条数据链路传送数据。

如果还需要传送文件，需要在打开一个数据连接。

# 3 Socket

## 3.1 ★★☆ 五种 IO 模型的特点以及比较。

输入操作包括两个阶段：

1.等待数据准备好（等待数据从网络到达）

2.从内核向进程复制数据（从内核缓冲区复制到应用进程缓冲区）

 

Unix五种I/O模型

- 阻塞式I/O

应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区才返回。

在阻塞过程中，其他应用进程还可以执行，不消耗CPU时间，这种模型的CPU利用率会比较高。

**recvfrom()用于接受Socket传来的数据，并复制到应用进程的缓冲区**

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsYCjMpg.jpg) 

 

- 非阻塞式I/O

应用进程执行一个系统调用后，内核返回一个错误码。应用进程可以继续执行，但是需要不断执行系统调用来获知I/O是否完成，称为轮询

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsUbB15X.jpg) 

 

- I/O复用（select和poll）

使用select或者poll等待数据，并且可以等待多个套接字的任何一个变为可读。这个过程会被阻塞，当某个套接字可读时返回，在使用recvfrom把数据从内核复制到进程中。

它可以让单个进程具有处理多个I/O事件的能力。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsnvNzMv.jpg) 

- 信号驱动式I/O(SIGIO)

应用进程使用sigaction系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段进程是非阻塞的。内核在数据到达时向应用进程发送SIGIO信号，应用进程收到后调用recvfrom将数据从内核复制到应用进程。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsTe9uFV.jpg) 

 

- 异步I/O(AIIO)

应用进程执行aio_read系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核在所有操作完成后向应用进程发送信号。

![img](file:////private/var/folders/gw/tm5w3wzx75b28wcz_7klvkxm0000gn/T/com.kingsoft.wpsoffice.mac/wps-zhupeihao/ksohtml/wpsgmUGV1.jpg)‘

 

**五种I/O的比较**

- 同步I/O：将数据从内核缓冲区复制到应用进程缓冲区时会阻塞（第二阶段）
- 异步I/O；第二阶段不会阻塞

 

同步I/O包括阻塞式I/O、非阻塞式I/O、I/O复用和信号驱动I/O，他们之间主要区别在第一阶段，

非阻塞I/O、信号驱动I/O和异步I/O第一阶段不会阻塞。

 

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1492928105791_3.png)





#### 有哪些常见的IO模型？

- 同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；
- 同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；
- IO多路复用
- 异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。



## 3.2 ★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。

IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。

实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。

<details>
<summary>select/poll/epoll三者的区别？</summary>


- ```select```：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间

  （缺点1：每次都要复制，**开销大**），由内核根据就绪状态修改该集合的内容。

  （缺点2）**集合大小有限制**，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符

  （缺点3：**轮询的方式效率较低**），当文件描述符的数量增加时，效率会线性下降；

- ```poll```：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；

- ```epoll```：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

总结，区别主要在于：

- 一个线程/进程所能打开的最大连接数
- 文件描述符传递方式（是否复制）
- 水平触发 or 边缘触发
- 查询就绪的描述符时的效率（是否轮询）

#### 什么时候使用select/poll，什么时候使用epoll？

当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。

#### 什么是文件描述符？

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

**内核通过文件描述符来访问文件。文件描述符指向一个文件。**



#### 什么是水平触发？什么是边缘触发？

https://blog.csdn.net/lihao21/article/details/67631516

- 水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知（但是进程不一定要立即处理），如果用户程序没有一次性把数据读写完，下次调用epoll_wait()还会通知进程。是默认的一种模式，支持阻塞和非阻塞；

- 边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知（因为进程必须立即处理描述符），直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。

  

  **水平触发**

  1. 对于读操作
  只要缓冲内容不为空，LT模式返回读就绪。

  2. 对于写操作
  只要缓冲区还不满，LT模式会返回写就绪。

  **边缘触发**

  1. 对于读操作
  （1）当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。

  （2）当有新数据到达时，即缓冲区中的待读数据变多的时候。

  （3）当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时。

  2. 对于写操作
  （1）当缓冲区由不可写变为可写时。

  （2）当有旧数据被发送走，即缓冲区中的内容变少的时候。

  （3）当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。
  

  **区别：**边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。

  

  **为什么边缘触发一定要用非阻塞（non-block）IO：**因为边缘触发当描述符就绪时就会立即处理，避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态（如果短时间内很多描述符都就绪了，如果采用阻塞IO的话就会）。

