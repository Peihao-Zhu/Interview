# 1.面向对象思想

## 1.1★★★ 面向对象三大特性

1. **封装**

   利用抽象数据类型将数据和相应的操作封装在一起。隐藏内部细节，只保留一些对外的接口。

   优点：

   - 减少耦合
   - 减轻维护的负担
   - 有效调节性能：可以通过剖析来确定哪些模块影响了性能
   - 提高软件的可重用性
   - 降低了构建大型系统的风险

2. **继承**

   继承实现了IS-A关系，子类能获得父类非private的属性和方法

   继承应该遵守里氏替换原则，子类对象必须能够替换掉所有父类对象

   可以用父类应用指向子类对象，称为**向上转型**。

   ```java
   Animal animal=new Cat();
   ```

   

3. **多态**

   编译时多态和运行时多态

   - 编译时多态：方法重载

   - 运行时多态：程序中定义的对象引用所指向具体类型在运行期间才确定。

     

     运行时多态有三个条件

   - 继承
   - 覆盖（重写）
   - 向上转型

   

## 1.2 ★☆☆设计原则

1. 单一责任原则

   一个类只负责一件事，当这个类需要做过多事情时，就需要分解这个类

2. 开放封闭原则

   类应该对扩展开放，对修改封闭

3. 里氏替换原则

   子类对象必须能够替换掉所有父类对象

4. 接口分离原则

   不应该强迫依赖根本不使用的方法，所以使用多个专门的接口比使用单一总接口要好

5. 依赖倒置原则

   高层模块不应该依赖于低层模块，二者都应该依赖于抽象；

   抽象不应该依赖于细节。

# 2.设计模式

### 2.1 ★★☆ 设计模式的作用。

#### 	设计模式是什么

​		设计模式是一个通过定义、使用、测试去解决特定问题的方法，是针对软件设计中在给定条件下会重复性发生的问题而提出的一种通用性的可重用解决方案，设计模式不是可以直接转化为代码的完整设计，它是用于描述在不同情况下解决问题的通用方案。

#### 	设计模式的作用

​		设计模式通过提供经过验证的行之有效的开发范式加快开发过程，预防重大隐患问题，提高代码可读性。

### 2.2 ★★★ 手写单例模式，特别是双重检验锁以及静态内部类。

一个类只能有一个实例：一个私有构造函数（不会通过构造函数创建实例对象），一个私有静态变量以及一个公有静态函数

懒汉式和饿汉式的区别是类实例话被动和主动的区别。

1. 懒汉式---线程不安全

   ```java
   public class Singleton{
   		private static Singleton uniqueInstance;
   		
   		private Singleton{
   		}
   		
   		//获取对象的唯一实例
   		public static Singleton getUniqueInstance(){
   			//如果没有被初始化
   			if(uniqueInstance==null){
   				uniqueInstance=new Singleton();
   			}
   			return uniqueInstance;
   		}
   		
   }
   ```

   可以发现，私有静态变量uniqueInstance被延迟初始化，只有调用**getUniqueInstance()** 时才会初始化，这样做的好处是，如果没用到该类，就不会实例话，节约资源。

   这个代码很明显是线程不安全的，如果多个线程同时进入到 **if(uniqueInstance==null)** 那么这个实例就会被初始化多次。

   

2. 饿汉式--线程安全

   可以在申明的时候直接实例化，但是没有延迟实例化带来的节约资源的特点

   ```java
   private static Singleton uniqueInstance = new Singleton();
   ```

   

3. 懒汉式--线程安全

   在公有静态函数，获取实例的时候加锁，但是这会导致每次进入该方法的线程都要等待，无论是否已经实例化过，这会让线程等待很多时间。

   ```java
   public static synchronized Singleton getUniqueInstance()
   ```

   

4. 双重检验锁

   对需要实例话部分的代码块加锁。这里需要用到双重检验，因为在第一个 **if(uniqueInstance==null)** 处可能有多个线程同时进来，如果没有第二个 **if(uniqueInstance==null)**，虽然实例化的过程是一个线程接着一个线程，但是该对象还是会被实例话多次。所以在之后还要判断是否已经实例化。

   ```java
   public class Singleton {
   
       private volatile static Singleton uniqueInstance;
   
       private Singleton() {
       }
   
       public static Singleton getUniqueInstance() {
           if (uniqueInstance == null) {
               synchronized (Singleton.class) {
                   if (uniqueInstance == null) {
                       uniqueInstance = new Singleton();
                   }
               }
           }
           return uniqueInstance;
       }
   }
   
   ```

   并且uniqueInstance是volatile， **uniqueInstance = new Singleton();** 这段代码是分为三个步骤执行的

   - 为uniqueInstance分配内存空间
   - 初始化uniqueInstance
   - 将uniqueInstance指向分配的内存地址

   因为JVM具有指令重排的特性，执行顺序可能变成1->3->2。如果在多线程环境下，可能存在一个线程初始化执行了1和3，此时另一个线程调用了getUniqueInstance()发现uniqueInstance不为空，但uniqueInstance并没有被初始化。

   volatile的作用是为了禁止指令的重排序。

   

5. 静态内部类

   当Singleton类被加载时，静态内部类SingletonHolder并没有被加载进内存，只有当调用 **getUniqueInstance()** 方法，从而触发 **SingletonHolder.INSTANCE** ，初始化INSTANCE实例，并且JVM能确保INSTANCE值只被实例化一次。

   ```java
   public class Singleton {
   
       private Singleton() {
       }
   
       private static class SingletonHolder {
           private static final Singleton INSTANCE = new Singleton();
       }
   
       public static Singleton getUniqueInstance() {
           return SingletonHolder.INSTANCE;
       }
   }
   ```

   

### 2.3 ★★★ 手写工厂模式。

https://www.cnblogs.com/zailushang1996/p/8601808.html

https://blog.csdn.net/liuguangxu1988/article/details/82053951

三种工厂模式

1. 简单工厂模式

   ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png)

   把实例化的操作都放到SimpleFactory中，这个类是具体的，非接口 抽象类。createProduct（）是静态的，也称为静态工厂。

   

   缺点：

   - 扩展性差，如果要增加一个产品类，需要修改工厂类方法，不符合开闭原则。
   - 不同产品需要不同额外参数的时候不支持

   

2. 工厂方法模式

   ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png)

   Factory类是抽象类/接口类，让他的子类/实现类来决定实例化哪个产品，并且由该实现类来创建对应的产品类实例。

   

   优点：一定程度增加扩展性，如果新增一个产品，只需要在实现具体的工厂类，在该类中重写factoryMethod（）方法。

   

   **使用场景**

   消费者不关心他要创建对象的类（产品类）

   消费者知道他要创建对象的类，但是不关心如何创建。

   

3. 抽象工厂模式

   ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png)

   为创建一组相关或相互依赖的对象提供一个接口，并且无需制定他们的具体类。



​	抽象工厂模式和工厂方法模式的区别：

​		抽象工厂模式是工厂方法模式的升级版，他用来创建一组相关或者相互依赖的对象。工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构。抽象工厂模式有一个产品族的概念（位于不同产品等级结构中功能相关联的产品组成的家族）

​		举例：两厢车和三厢车是两个不同的等级结构；2.0排量车和2.4排量车是两个不同的产品族，2.0排量车包括2.0排量两厢车和2.0排量三厢车。

​	

​	抽象工厂模式

​		优点：可以在类内部对产品族进行约束

​		缺点：产品族的扩展很费力，需要修改几乎所有的工厂类。



总结：无论使用哪种工厂模式，最终目的就是为了客户类和子类的接耦。

### 2.4 ★★★ 理解 MVC，结合 SpringMVC 回答。



### 2.5 ★★★ 理解代理模式，结合 Spring 中的 AOP 回答。

https://www.jianshu.com/p/471c80a7e831



Java中的代理一般分为三种：**JDK静态代理**、**JDK动态代理**、**CGLIB代理**。 在Spring AOP的实现中主要应用了JDK动态代理以及CGLIB代理，



**JDK静态代理**

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png)

```java
//接口
public interface HelloInterface{
	void sayHello();
}
//被代理类
public class hello inplements helloInterface{
	@Override
	public void sayHello(){
		System.out.println("Hello man");
	}
}
//代理类
public class helloProxy inplements helloInterface{
	private Hello hello=new Hello();
	
	@Override
	public void sayHello(){
		System.out.println("Before");
		hello.sayHello();
		System.out.println("After");
	}
}


```

实质就是代理类为被代理类预处理消息、过滤消息并在此之后转发给被代理类。代理类本身不提供服务，而是调用被代理类中的方法来提供。

静态代理存在一个问题！！！！代理类只能为一个类提供服务，如果需要代理其他的类，需要编写很多代码。



**动态代理**

```java
//接口
public interface HelloInterface{
	void sayHello();
}
//被代理类
public class hello inplements helloInterface{
	@Override
	public void sayHello(){
		System.out.println("Hello man");
	}
}
//代理类
public class helloProxy inplements helloInterface{
	private Hello hello;
	
  public helloProxy(Object subject){
    	this.hello=subject;
  }
	@Override
	public void sayHello(){
		System.out.println("Before");
		hello.sayHello();
		System.out.println("After");
	}
}
```



### 2.6 ★★★ 分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。

