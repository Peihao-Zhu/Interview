# 1.面向对象思想

## 1.1★★★ 面向对象三大特性

1. **封装**

   利用抽象数据类型将数据和相应的操作封装在一起。隐藏内部细节，只保留一些对外的接口。

   优点：

   - 减少耦合
   - 减轻维护的负担
   - 有效调节性能：可以通过剖析来确定哪些模块影响了性能
   - 提高软件的可重用性
   - 降低了构建大型系统的风险

2. **继承**

   继承实现了IS-A关系，子类能获得父类非private的属性和方法

   继承应该遵守里氏替换原则，子类对象必须能够替换掉所有父类对象

   可以用父类应用指向子类对象，称为**向上转型**。

   ```java
   Animal animal=new Cat();
   ```

   

3. **多态**

   编译时多态和运行时多态

   - 编译时多态：方法重载

   - 运行时多态：程序中定义的对象引用所指向具体类型在运行期间才确定。

     

     运行时多态有三个条件

   - 继承
   - 覆盖（重写）
   - 向上转型

   

## 1.2 ★☆☆设计原则

1. 单一责任原则

   一个类只负责一件事，当这个类需要做过多事情时，就需要分解这个类

2. 开放封闭原则

   类应该对扩展开放，对修改封闭

3. 里氏替换原则

   子类对象必须能够替换掉所有父类对象

4. 接口分离原则

   不应该强迫依赖根本不使用的方法，所以使用多个专门的接口比使用单一总接口要好

5. 依赖倒置原则

   高层模块不应该依赖于低层模块，二者都应该依赖于抽象；

   抽象不应该依赖于细节。

# 2.设计模式

### 2.1 ★★☆ 设计模式的作用。

#### 	设计模式是什么

​		设计模式是一个通过定义、使用、测试去解决特定问题的方法，是针对软件设计中在给定条件下会重复性发生的问题而提出的一种通用性的可重用解决方案，设计模式不是可以直接转化为代码的完整设计，它是用于描述在不同情况下解决问题的通用方案。

#### 	设计模式的作用

​		设计模式通过提供经过验证的行之有效的开发范式加快开发过程，预防重大隐患问题，提高代码可读性。

### 2.2 ★★★ 手写单例模式，特别是双重检验锁以及静态内部类。

一个类只能有一个实例：一个私有构造函数（不会通过构造函数创建实例对象），一个私有静态变量以及一个公有静态函数

懒汉式和饿汉式的区别是类实例话被动和主动的区别。

1. 懒汉式---线程不安全

   ```java
   public class Singleton{
   		private static Singleton uniqueInstance;
   		
   		private Singleton{
   		}
   		
   		//获取对象的唯一实例
   		public static Singleton getUniqueInstance(){
   			//如果没有被初始化
   			if(uniqueInstance==null){
   				uniqueInstance=new Singleton();
   			}
   			return uniqueInstance;
   		}
   		
   }
   ```

   可以发现，私有静态变量uniqueInstance被延迟初始化，只有调用**getUniqueInstance()** 时才会初始化，这样做的好处是，如果没用到该类，就不会实例话，节约资源。

   这个代码很明显是线程不安全的，如果多个线程同时进入到 **if(uniqueInstance==null)** 那么这个实例就会被初始化多次。

   

2. 饿汉式--线程安全

   可以在申明的时候直接实例化，但是没有延迟实例化带来的节约资源的特点

   ```java
   private static Singleton uniqueInstance = new Singleton();
   ```

   

3. 懒汉式--线程安全

   在公有静态函数，获取实例的时候加锁，但是这会导致每次进入该方法的线程都要等待，无论是否已经实例化过，这会让线程等待很多时间。

   ```java
   public static synchronized Singleton getUniqueInstance()
   ```

   

4. 双重检验锁

   对需要实例话部分的代码块加锁。这里需要用到双重检验，因为在第一个 **if(uniqueInstance==null)** 处可能有多个线程同时进来，如果没有第二个 **if(uniqueInstance==null)**，虽然实例化的过程是一个线程接着一个线程，但是该对象还是会被实例话多次。所以在之后还要判断是否已经实例化。

   ```java
   public class Singleton {
   
       private volatile static Singleton uniqueInstance;
   
       private Singleton() {
       }
   
       public static Singleton getUniqueInstance() {
           if (uniqueInstance == null) {
               synchronized (Singleton.class) {
                   if (uniqueInstance == null) {
                       uniqueInstance = new Singleton();
                   }
               }
           }
           return uniqueInstance;
       }
   }
   
   ```

   并且uniqueInstance是volatile， **uniqueInstance = new Singleton();** 这段代码是分为三个步骤执行的

   - 为uniqueInstance分配内存空间
   - 初始化uniqueInstance
   - 将uniqueInstance指向分配的内存地址

   因为JVM具有指令重排的特性，执行顺序可能变成1->3->2。如果在多线程环境下，可能存在一个线程初始化执行了1和3，此时另一个线程调用了getUniqueInstance()发现uniqueInstance不为空，但uniqueInstance并没有被初始化。

   volatile的作用是为了禁止指令的重排序。

   

5. 静态内部类

   当Singleton类被加载时，静态内部类SingletonHolder并没有被加载进内存，只有当调用 **getUniqueInstance()** 方法，从而触发 **SingletonHolder.INSTANCE** ，初始化INSTANCE实例，并且JVM能确保INSTANCE值只被实例化一次。

   ```java
   public class Singleton {
   
       private Singleton() {
       }
   
       private static class SingletonHolder {
           private static final Singleton INSTANCE = new Singleton();
       }
   
       public static Singleton getUniqueInstance() {
           return SingletonHolder.INSTANCE;
       }
   }
   ```

   

### 2.3 ★★★ 手写工厂模式。

https://www.cnblogs.com/zailushang1996/p/8601808.html

https://blog.csdn.net/liuguangxu1988/article/details/82053951

三种工厂模式

1. 简单工厂模式

   ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/40c0c17e-bba6-4493-9857-147c0044a018.png)

   把实例化的操作都放到SimpleFactory中，这个类是具体的，非接口/抽象类。createProduct（）是静态的，也称为静态工厂。

   

   缺点：

   - 扩展性差，如果要增加一个产品类，需要修改工厂类方法，不符合开闭原则。
   - 不同产品需要不同额外参数的时候不支持

   

2. 工厂方法模式

   ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png)

   Factory类是抽象类/接口类，让他的子类/实现类来决定实例化哪个产品，并且由该实现类来创建对应的产品类实例。

   

   优点：一定程度增加扩展性，如果新增一个产品，只需要在实现具体的工厂类，在该类中重写factoryMethod（）方法。

   

   **使用场景**

   消费者不关心他要创建对象的类（产品类）

   消费者知道他要创建对象的类，但是不关心如何创建。

   

3. 抽象工厂模式

   ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e2190c36-8b27-4690-bde5-9911020a1294.png)

   为创建一组相关或相互依赖的对象提供一个接口，并且无需制定他们的具体类。



​	抽象工厂模式和工厂方法模式的区别：

​		抽象工厂模式是工厂方法模式的升级版，他用来创建一组相关或者相互依赖的对象。工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构。抽象工厂模式有一个产品族的概念（位于不同产品等级结构中功能相关联的产品组成的家族）

​		举例：两厢车和三厢车是两个不同的等级结构；2.0排量车和2.4排量车是两个不同的产品族，2.0排量车包括2.0排量两厢车和2.0排量三厢车。

​	

​	抽象工厂模式

​		优点：可以在类内部对产品族进行约束

​		缺点：产品族的扩展很费力，需要修改几乎所有的工厂类。



总结：无论使用哪种工厂模式，最终目的就是为了客户类和子类的接耦。

### 2.4 ★★★ 理解 MVC，结合 SpringMVC 回答。

https://blog.csdn.net/qq_38449518/article/details/81545578

MVC并不是设计模式，是一种复合模式。

1.Model（模型）：就是业务逻辑层+数据层

2.View（视图）：Web程序的界面，对逻辑层拿到的数据进行渲染。

3.Controller（控制层）：获取用户的输入信息，进行解析防窥给模型。



#### SpringMVC框架

SpringMVC采用了松散耦合的可插拔组件，比其他MVC框架有更高的灵活性和扩展性。

SpringMVC围绕DispatcherServlet为中心展开，这就是一个Controller



**SpringMVC的特点**

1. 天生与Spring框架继承（IoC容器，AOP等）
2. 支持灵活的URL到页面控制层的映射
3. 容易和其他视图技术集成，如FreeMarker
4. 对静态资源的支持；支持Restful风格。

![img](https://img-blog.csdn.net/20180810092716689?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQ5NTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

注意：蓝色方框时Spring框架已经实现好的，前端控制器并不是控制器，是负责任务的分发，而控制器是Model的一部分，负责业务和数据处理。

![img](https://img-blog.csdn.net/20180810094245464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDQ5NTE4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 2.5 ★★★ 理解代理模式，结合 Spring 中的 AOP 回答。

https://www.jianshu.com/p/471c80a7e831

https://blog.csdn.net/Luckydog1991/article/details/51711474

代理模式根据目的和实现方式不同可以分为以下三种：‘

​	 1) 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中。

​	 2) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。

​     3) 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。

  

Java中的代理一般分为三种：**JDK静态代理**、**JDK动态代理**、**CGLIB代理**。 在Spring AOP的实现中主要应用了JDK动态代理以及CGLIB代理，



#### JDK静态代理

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b679ff5-94c6-48a7-b9b7-2ea868e828ed.png)

```java
//接口，也可以是抽象类，具体类
public interface HelloInterface{
	void sayHello();
}
//被代理类
public class hello inplements helloInterface{
	@Override
	public void sayHello(){
		System.out.println("Hello man");
	}
}
//代理类
public class helloProxy inplements helloInterface{
	private Hello hello=new Hello();
	
	@Override
	public void sayHello(){
		System.out.println("Before");
		hello.sayHello();
		System.out.println("After");
	}
}


```

实质就是代理类为被代理类预处理消息、过滤消息并在此之后转发给被代理类。代理类本身不提供服务，而是调用被代理类中的方法来提供。

静态代理存在一个问题！！！！代理类只能为一个类提供服务，如果需要代理其他的类，需要编写很多代码。



#### 动态代理

```java
//接口
public interface HelloInterface{
	void sayHello();
}
//被代理类
public class hello inplements helloInterface{
	@Override
	public void sayHello(){
		System.out.println("Hello man");
	}
}
//代理类
public class helloProxy inplements helloInterface{
	private Object subject;
	
  public helloProxy(Object subject){
    	this.subject=subject;
  }
  //InvocationHandler 方法会自动调用invoke，并根据传入的代理对象、方法名称、参数决定调用代理的哪个方法
	@Override
	public Object invoke(Object proxy, Method method, Object[] args)throws Throwable{
		System.out.println("Before"+method.getName());
		method.invoke(subject,args);
		System.out.println("After"+,method.getName());
    return null;
	}
}

//测试类

public class client{
  public static void main(String[] args){
    Hello hello=new Hello();
    InvocationHandler handler=new HelloProxy(hello);
    
    HelloInterface helloInterface=(HelloInterface)Proxy.newProxyInstance(handler.getClass().getClassLoader(),hello.getClass().getInterface(),handler);
    helloInterface.sayHello();
  }
}
```

可以发现在动态代理也要创建代理类，以及代理类都要实现接口。但是和静态代理的区别也比较明显----在静态代理中需要对哪个接口和那个被代理类创建代理类，在编译前就需要代理类实现与被代理类相同的接口，并且在实现的方法中调用被代理类相应的方法；但是动态代理不同，我们不知道要针对哪个接口、那个被代理类创建代理类，这个操作是在运行时被创建的。

更详细的说JDK静态代理是通过直接编码创建的，而JDK动态代理是利用**反射机制**在运行时创建代理类。其中在动态代理中，核心是InvocationHandler。每一个代理的实例都会有一个关联的调用处理程序（InvocationHandler）。对代理实例进行调用时（hello），将其方法的调用进行编码并指派到他的调用处理器（InvocationHandler）的invoke方法中完成，而invoke方法会根据传入的代理对象，方法名称，参数决定调用代理的哪个方法。

从测试类中可以发现代理类生成是通过Proxy类中的newProxyInstance来完成的，看一下其源码

```java
 public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        //如果h为空将抛出异常
        Objects.requireNonNull(h);

        final Class<?>[] intfs = interfaces.clone();//拷贝被代理类实现的一些接口，用于后面权限方面的一些检查
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            //在这里对某些安全权限进行检查，确保我们有权限对预期的被代理类进行代理
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * 下面这个方法将产生代理类
         */
        Class<?> cl = getProxyClass0(loader, intfs);

        /*
         * 使用指定的调用处理程序获取代理类的构造函数对象
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            //假如代理类的构造函数是private的，就使用反射来set accessible
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            //根据代理类的构造函数来生成代理类的对象并返回
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
```

代理类其实是通过getProxyClass0方法来生成的：

```java
 /**
     * 生成一个代理类，但是在调用本方法之前必须进行权限检查
     */
    private static Class<?> getProxyClass0(ClassLoader loader,
                                           Class<?>... interfaces) {
        //如果接口数量大于65535，抛出非法参数错误
        if (interfaces.length > 65535) {
            throw new IllegalArgumentException("interface limit exceeded");
        }

       
        // 如果在缓存中有对应的代理类，那么直接返回
        // 否则代理类将有 ProxyClassFactory 来创建
        return ProxyClassFactory.get(loader, interfaces);
    }
```

来看一下ProxyClassFactory

```java
   /**
     *  里面有一个根据给定ClassLoader和Interface来创建代理类的工厂函数  
     *
     */
    private static final class ProxyClassFactory
        implements BiFunction<ClassLoader, Class<?>[], Class<?>>
    {
        // 代理类的名字的前缀统一为“$Proxy”
        private static final String proxyClassNamePrefix = "$Proxy";

        // 每个代理类前缀后面都会跟着一个唯一的编号，如$Proxy0、$Proxy1、$Proxy2
        private static final AtomicLong nextUniqueNumber = new AtomicLong();

        @Override
        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {

            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
            for (Class<?> intf : interfaces) {
                /*
                 * 验证类加载器加载接口得到对象是否与由apply函数参数传入的对象相同
                 */
                Class<?> interfaceClass = null;
                try {
                    interfaceClass = Class.forName(intf.getName(), false, loader);
                } catch (ClassNotFoundException e) {
                }
                if (interfaceClass != intf) {
                    throw new IllegalArgumentException(
                        intf + " is not visible from class loader");
                }
                /*
                 * 验证这个Class对象是不是接口
                 */
                if (!interfaceClass.isInterface()) {
                    throw new IllegalArgumentException(
                        interfaceClass.getName() + " is not an interface");
                }
                /*
                 * 验证这个接口是否重复
                 */
                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                    throw new IllegalArgumentException(
                        "repeated interface: " + interfaceClass.getName());
                }
            }

            String proxyPkg = null;     // 声明代理类所在的package
            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

            /*
             * 记录一个非公共代理接口的包，以便在同一个包中定义代理类。同时验证所有非公共
             * 代理接口都在同一个包中
             */
            for (Class<?> intf : interfaces) {
                int flags = intf.getModifiers();
                if (!Modifier.isPublic(flags)) {
                    accessFlags = Modifier.FINAL;
                    String name = intf.getName();
                    int n = name.lastIndexOf('.');
                    String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                    if (proxyPkg == null) {
                        proxyPkg = pkg;
                    } else if (!pkg.equals(proxyPkg)) {
                        throw new IllegalArgumentException(
                            "non-public interfaces from different packages");
                    }
                }
            }

            if (proxyPkg == null) {
                // 如果全是公共代理接口，那么生成的代理类就在com.sun.proxy package下
                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
            }

            /*
             * 为代理类生成一个name  package name + 前缀+唯一编号
             * 如 com.sun.proxy.$Proxy0.class
             */
            long num = nextUniqueNumber.getAndIncrement();
            String proxyName = proxyPkg + proxyClassNamePrefix + num;

            /*
             * 生成指定代理类的字节码文件
             */
            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
            try {
                return defineClass0(loader, proxyName,
                                    proxyClassFile, 0, proxyClassFile.length);
            } catch (ClassFormatError e) {
                /*
                 * A ClassFormatError here means that (barring bugs in the
                 * proxy class generation code) there was some other
                 * invalid aspect of the arguments supplied to the proxy
                 * class creation (such as virtual machine limitations
                 * exceeded).
                 */
                throw new IllegalArgumentException(e.toString());
            }
        }
    }
```

由上方代码*byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);*可以看到，其实生成代理类字节码文件的工作是通过 ProxyGenerate类中的generateProxyClass方法来完成的。

```java
 public static byte[] generateProxyClass(final String var0, Class<?>[] var1, int var2) {
        ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);
       // 真正用来生成代理类字节码文件的方法在这里
        final byte[] var4 = var3.generateClassFile();
       // 保存代理类的字节码文件
        if(saveGeneratedFiles) {
            AccessController.doPrivileged(new PrivilegedAction() {
                public Void run() {
                    try {
                        int var1 = var0.lastIndexOf(46);
                        Path var2;
                        if(var1 > 0) {
                            Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar), 
                                                                                   new String[0]);
                            Files.createDirectories(var3, new FileAttribute[0]);
                            var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class");
                        } else {
                            var2 = Paths.get(var0 + ".class", new String[0]);
                        }

                        Files.write(var2, var4, new OpenOption[0]);
                        return null;
                    } catch (IOException var4x) {
                        throw new InternalError("I/O exception saving generated file: " + var4x);
                    }
                }
            });
        }

        return var4;
    }
```

下面来看看真正用于生成代理类字节码文件的**generateClassFile**方法：

```java
private byte[] generateClassFile() {
        //下面一系列的addProxyMethod方法是将接口中的方法和Object中的方法添加到代理方法中(proxyMethod)
        this.addProxyMethod(hashCodeMethod, Object.class);
        this.addProxyMethod(equalsMethod, Object.class);
        this.addProxyMethod(toStringMethod, Object.class);
        Class[] var1 = this.interfaces;
        int var2 = var1.length;

        int var3;
        Class var4;
       //获得接口中所有方法并添加到代理方法中
        for(var3 = 0; var3 < var2; ++var3) {
            var4 = var1[var3];
            Method[] var5 = var4.getMethods();
            int var6 = var5.length;

            for(int var7 = 0; var7 < var6; ++var7) {
                Method var8 = var5[var7];
                this.addProxyMethod(var8, var4);
            }
        }

        Iterator var11 = this.proxyMethods.values().iterator();
        //验证具有相同方法签名的方法的返回类型是否一致
        List var12;
        while(var11.hasNext()) {
            var12 = (List)var11.next();
            checkReturnTypes(var12);
        }

        //后面一系列的步骤用于写代理类Class文件
        Iterator var15;
        try {
             //生成代理类的构造函数
            this.methods.add(this.generateConstructor());
            var11 = this.proxyMethods.values().iterator();

            while(var11.hasNext()) {
                var12 = (List)var11.next();
                var15 = var12.iterator();

                while(var15.hasNext()) {
                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();
                    //将代理类字段声明为Method，并且字段修饰符为 private static.
                   //因为 10 是 ACC_PRIVATE和ACC_STATIC的与运算 故代理类的字段都是 private static Method ***
                    this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, 
                                   "Ljava/lang/reflect/Method;", 10));
                   //生成代理类的方法
                    this.methods.add(var16.generateMethod());
                }
            }
           //为代理类生成静态代码块对某些字段进行初始化
            this.methods.add(this.generateStaticInitializer());
        } catch (IOException var10) {
            throw new InternalError("unexpected I/O Exception", var10);
        }

        if(this.methods.size() > '\uffff') { //代理类中的方法数量超过65535就抛异常
            throw new IllegalArgumentException("method limit exceeded");
        } else if(this.fields.size() > '\uffff') {// 代理类中字段数量超过65535也抛异常
            throw new IllegalArgumentException("field limit exceeded");
        } else {
            // 后面是对文件进行处理的过程
            this.cp.getClass(dotToSlash(this.className));
            this.cp.getClass("java/lang/reflect/Proxy");
            var1 = this.interfaces;
            var2 = var1.length;

            for(var3 = 0; var3 < var2; ++var3) {
                var4 = var1[var3];
                this.cp.getClass(dotToSlash(var4.getName()));
            }

            this.cp.setReadOnly();
            ByteArrayOutputStream var13 = new ByteArrayOutputStream();
            DataOutputStream var14 = new DataOutputStream(var13);

            try {
                var14.writeInt(-889275714);
                var14.writeShort(0);
                var14.writeShort(49);
                this.cp.write(var14);
                var14.writeShort(this.accessFlags);
                var14.writeShort(this.cp.getClass(dotToSlash(this.className)));
                var14.writeShort(this.cp.getClass("java/lang/reflect/Proxy"));
                var14.writeShort(this.interfaces.length);
                Class[] var17 = this.interfaces;
                int var18 = var17.length;

                for(int var19 = 0; var19 < var18; ++var19) {
                    Class var22 = var17[var19];
                    var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));
                }

                var14.writeShort(this.fields.size());
                var15 = this.fields.iterator();

                while(var15.hasNext()) {
                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();
                    var20.write(var14);
                }

                var14.writeShort(this.methods.size());
                var15 = this.methods.iterator();

                while(var15.hasNext()) {
                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();
                    var21.write(var14);
                }

                var14.writeShort(0);
                return var13.toByteArray();
            } catch (IOException var9) {
                throw new InternalError("unexpected I/O Exception", var9);
            }
        }
    }
```

下面是将接口与Object中一些方法添加到代理类中的addProxyMethod方法：

```java
private void addProxyMethod(Method var1, Class<?> var2) {
        String var3 = var1.getName();//获得方法名称
        Class[] var4 = var1.getParameterTypes();//获得方法参数类型
        Class var5 = var1.getReturnType();//获得方法返回类型
        Class[] var6 = var1.getExceptionTypes();//异常类型
        String var7 = var3 + getParameterDescriptors(var4);//获得方法签名
        Object var8 = (List)this.proxyMethods.get(var7);//根据方法前面获得proxyMethod的value
        if(var8 != null) {//处理多个代理接口中方法重复的情况
            Iterator var9 = ((List)var8).iterator();

            while(var9.hasNext()) {
                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod)var9.next();
                if(var5 == var10.returnType) {
                    ArrayList var11 = new ArrayList();
                    collectCompatibleTypes(var6, var10.exceptionTypes, var11);
                    collectCompatibleTypes(var10.exceptionTypes, var6, var11);
                    var10.exceptionTypes = new Class[var11.size()];
                    var10.exceptionTypes = (Class[])var11.toArray(var10.exceptionTypes);
                    return;
                }
            }
        } else {
            var8 = new ArrayList(3);
            this.proxyMethods.put(var7, var8);
        }

        ((List)var8).add(new ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2, null));
    }
```

以上都是JDK动态代理的源码，可能会看的一头雾水，不过没有关系，俺也没看懂，有时间在重复的回去看。

###### 这里总结一下JDK动态代理：代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能动态代理，因为newProxyInstance的第二个参数需要传入目标对象的接口



#### CGLIB

上面的静态代理和动态代理都是要求目标对象实现一个接口，但是有时候目标对象没有实现任何接口，这时可以使用CGLIB代理，也叫做子类代理，它是内存中构建一个子类对象从而实现对目标对象功能的扩展。

CGLIB子类代理实现方法：

1. 需要引入cglib的jar文件，但是Spring的核心包中包括了cglib功能，所以直接引入pring-core-3.2.5.jar即可。
2. 引入功能包后，就可以在内存中动态构建子类
3. 代理的类不能使用final，否则报错
4. 目标对象的方法如果为final/static，那么就不会被拦截，既不会执行对象额外的业务开发



**JDK动态代理和CGLIB字节码生成的区别？**

（1）JDK动态代理只能对实现了接口的类生成代理

（2）CGLIB是针对类实现代理，主要是针对指定的类生成的子类，覆盖其中的方法。



**Spring在选择用JDK还是CGLIB的依据？**

当Bean实现接口时，Spring会用JDK动态代理；反之使用CGLIB；也可以强制使用CGLIB（在spring配置中加入<aop:aspectj-autoproxy proxy-target-class="true"/>）



**CGLIB比JDK快？**

（1）使用CGLIB实现动态代理，底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率高。但是CGLIB不能对申明为final的方法进行代理，因为其是动态生成被代理类的子类（而final类不能被继承）





### 2.6 ★★★ 分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。

#### 装饰者模式

https://blog.csdn.net/luckydog1991/article/details/51706073

![img](https://img-blog.csdn.net/20160618154641182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

```java
//抽象组件，申明了组件的业务方法 
abstract class Component{
 
  abstract protected void operation();
 
 }
//具体的组件，实现了抽象组件中申明的业务方法
 class ConcreteComponent extends Component{
  @Override
  protected void operation() {
   // TODO Auto-generated method stub
   //具体组件类操作内容
  }    
 }
//抽象装饰器，用于给具体组件增加职责，这里只是申明职责，具体的实现方法在其子类中实现
//这里维护了一个指向抽象组件对象的引用，通过这个引用实现装饰之前实现的业务，然后自己在增加新的职责
 abstract class Decorator  extends Component {        
  private Component component ;
 
   public Decorator(Component conponent){
    this.component = conponent;
   }
  @Override
  protected void operation() {
   // TODO Auto-generated method stub
   component.operation();
  }
   
 }
 //具体的装饰器，是抽象装饰器的子类，实现了父类申明的职责，定义一些新的行为
 class ConcreteDecorator extends Decorator{
  public ConcreteDecorator(Component conponent) {
   super(conponent);
   // TODO Auto-generated constructor stub
  }
  @Override
  protected void operation() {
   // TODO Auto-generated method stub
   super.operation();
   
   addedFuncction();
  }
 
  private void addedFuncction(){
   //附加的装饰性功能
  }
 }
```

适用场景：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加新功能、新职责；除此之外，如果遇到不能采用继承方式扩展或继承不利于系统扩展时也适用装饰者模式。



##### JDK中装饰者的应用

JavaIO包基本基类InputStream、OutputStream、Reader和Writer以及InputStreamReader、OutputStreamReader。InputStream和OutputStream处理8位字节流，Reader和Writer处理16为字符流数据。各个体系内部都适用装饰者模式，而InputStream和InputStreamReader使用了适配器模式。

InputStream的类关系 ：
class java.lang.Object 
| 
|—class java.io.InputStream //输入流，字节形式，为以下的基类 
| | 
| |——ByteArrayInputStream //从字节数组中读取 
| | 
| |——FileInputStream //从文件中读取数据 
| | 
| |—— FilterInputStream //过滤流的基类, 
| | | // 过滤可以了解为各种处理技术的形象称呼 
| | | 
| | |——BufferedInputStream //缓冲技术， 
| | | // 数据来自底层输入流 
| | | 
| | |——DataInputStream //可读java数据类型 
| | | 
| | | 
| | |——java.util.zip.GZIPInputStream 

InputStream就是Component，ByteArrayInputStream和FileInputStream相当于被装饰者（ConcreteComponent），这些类提供了最基本的字节读取功能。而FilterInputStream是装饰者。BufferedInputStream和DataInputStream是被装饰者修饰后形成的成品。



#### 适配器模式

https://blog.csdn.net/Luckydog1991/article/details/51704764

适配器模式将一个接口转换为客户希望的另一个接口，在适配器模式中，通过增加一个新的适配器类来解决接口不兼容问题。根据适配器类和适配者之间的关系不同，适配器模式可以分为对象适配器和类适配器两种；对象适配器中适配器和适配者是关联关系；在类适配器中两者之间是继承（或实现）关系。

![img](https://img-blog.csdn.net/20160618095513115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

组成：

（1）ClientTarget（目标抽象类）：定义了客户会使用的接口，可以是抽象类、接口或具体类

（2）Adapter（适配器类）：适配器可以调用另一个接口，对Adaptee和Target进行适配。

（3）AdapteeTarget（适配者类）：被适配的角色，定义一个已经存在的接口，这个接口需要被适配（也就是客户想要使用的业务方法）。

在对象适配器中，客户端需要调用ClientTarget的request（）方法，但是真正实现业务逻辑的是AdapteeTarget的specificRequest（）方法，为了能让客户端使用适配者类，需要一个适配器类，包含适配者类的实例，从而将客户端与适配者类联系起来。

```java
abstract class ClientTarget{
   protected void request(){
   }
 }   
class AdapteeTarget{           
     public	AdapteeTarget(){     
  }
     void	specialcRequect(){  
     }    
 }   
//对象适配器模式；和类适配器的区别就是类适配器是实现或者继承适配者
class Adapter  extends ClientTarget{
  private AdapteeTarget adaptee ;//关联关系
  
  public Adapter(AdapteeTarget adaptee){
   this.adaptee = adaptee;
  }
  @Override
  protected void request() {
   // TODO Auto-generated method stub
   adaptee.specialcRequect();
  }   
 }
```

适用场景：系统需要使用现有的类，而这些类的接口不符合系统需要，甚至没有这些类的源代码。

总结：适配器模式将目标类和适配者类解耦

##### 	JDK中适配器模式的应用

如集合包中java.util.Arrays#asList()、io包中java.io.InputStreamReader(InputStream)、java.io.OutputStreamWriter(OutputStream) 等。

Reader 类对应ClientTarget抽象类，InputStreamReader 类对应Adapter类，  InputStream 对应AdapteeTarget。InputStreamReader 将Reader 接口和InputStream 接口适配起来。

```java
   public class InputStreamReader extends Reader {
    private final StreamDecoder sd;
//构造函数，传入InputStream 对象in，并且关联在StreamDecoder sd对象中，
    public InputStreamReader(InputStream in) {
        super(in);
        try {
            sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object
        } catch (UnsupportedEncodingException e) {
            // The default encoding should always be available
            throw new Error(e);
        }
    }
 
 //适配Reader 接口中字符读取操作，调用sd中字节读取转化为字符读取。
    public int read() throws IOException {
        return sd.read();
    }
 
}
```

Reader本身是字符读取，通过InputStreamReader适配器可以实现一串字节流的读取

#### 迭代器模式

提供一种顺序访问聚合对象元素，并且不暴露聚合对象的内部表示

![image-20191130164425351](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191130164425351.png)

组成：

（1）Aggregate 聚合类：其中createIterator（）方法可以产生一个Iterator；

（2）Iterator定义了hasNext（）和next（）方法；

（3）Client组合了Aggregate，为了迭代变了Aggregate，也组合了Iterator。

##### JDK中迭代器模式的应用

JDK中迭代器的应用有Iterator，Enumeration（迭代器类），还有List（聚合类）

![img](https://img2020.cnblogs.com/blog/1542615/202007/1542615-20200707003817138-1254716788.png)

ArrayList是一个具体的聚合类（实现了产生迭代器的方法），内部有一个Itr类是具体的迭代器类

```java
  
//产生迭代器
  public Iterator<E> iterator() {
        return new Itr();
    }
//具体的迭代器
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        // prevent creating a synthetic constructor
        Itr() {}

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
        ...
        }
   }
```

JDK中有一个Iterator接口----Iterator

在ArrayList的内部类Itr中实现了Iterator接口-----ConcreteIterator

List是聚合接口，含有一个iterator方法，返回一个迭代器对象----Aggregate

ArrayList实现了聚合接口，实现了iterator（）-----ConcreteAggregate



**优点：**

1. 迭代器模式解决了不同集合（ArrayList，LinkedList）统一遍历的问题
2. 隐藏聚合的内部结构，客户端遍历聚合对象的时候，只能取迭代器，而不用知道聚合的具体组成
3. 一个类应该只有一个引起变化的原因（单一职责原则）。在聚合类中我们吧迭代器分开，就是把管理对象集合和遍历对象集合的责任分开，这样一来如果集合改变的话，只能影响到聚合对象，如果遍历方式改变的话只能影响到迭代器。
4. 展示一组相似对象或者遍历一组相同对象时就适合使用迭代器。